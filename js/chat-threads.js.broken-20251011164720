(function ($) {
	'use strict';
	let lastMessageId = 0;
	window.LMSChat = window.LMSChat || {};
	window.LMSChat.state = window.LMSChat.state || {};
	window.LMSChat.utils = window.LMSChat.utils || {};

	// シンプルで確実なスレッド閉じる処理
	window.forceCloseThread = function () {
		const $threadPanel = $('.thread-panel');
		// 現在のスレッドIDを取得（リセット前に）
		const closingThreadId = $threadPanel.attr('data-current-thread-id');

		// パネルのクラスとスタイルを完全にリセット
		$threadPanel.removeClass('open show closing opening');
		$threadPanel.removeAttr('data-current-thread-id');
		$threadPanel.hide().css({
			right: '',
			opacity: '',
			visibility: '',
			transform: '',
			display: 'none',
		});
		$('body').removeClass('thread-open');

		// すべての状態を確実にリセット
		if (window.LMSChat?.state) {
			window.LMSChat.state.currentThread = null;
			window.LMSChat.state.lastThreadMessageId = 0;
			window.LMSChat.state.unreadThreadMessages = [];
		}
		if (typeof state !== 'undefined' && state) {
			state.currentThread = null;
			state.lastThreadMessageId = 0;
			state.unreadThreadMessages = [];
		}

		// イベントをトリガー（閉じたスレッドIDを含めて）
		$(document).trigger('thread:closed', [closingThreadId]);
		return true;
	};
	const formatRelativeTimeInline = (timestamp) => {
		if (!timestamp) {
			return '';
		}
		const now = new Date();
		const target = new Date(timestamp);
		if (isNaN(target.getTime())) {
			return '';
		}
		const diffInSeconds = Math.floor((now - target) / 1000);
		if (diffInSeconds < 60) {
			return '1分前';
		} else if (diffInSeconds < 3600) {
			const minutes = Math.floor(diffInSeconds / 60);
			return `${minutes}分前`;
		} else if (diffInSeconds < 86400) {
			const hours = Math.floor(diffInSeconds / 3600);
			return `${hours}時間前`;
		} else if (diffInSeconds < 2592000) {
			const days = Math.floor(diffInSeconds / 86400);
			return `${days}日前`;
		} else if (diffInSeconds < 31536000) {
			const months = Math.floor(diffInSeconds / 2592000);
			return `${months}ヶ月前`;
		} else {
			const years = Math.floor(diffInSeconds / 31536000);
			return `${years}年前`;
		}
	};
	const { state, utils } = window.LMSChat;
	const formatMessageTime =
		utils.formatMessageTime ||
		function (dateString) {
			return new Date(dateString).toLocaleTimeString('ja-JP', {
				hour: '2-digit',
				minute: '2-digit',
			});
		};
	if (!state.lastThreadMessageId) {
		state.lastThreadMessageId = 0;
	}
	if (!state.unreadThreadMessages) {
		state.unreadThreadMessages = [];
	}
	const processOptimisticDelete = (messageId, $message) => {
		// この関数は使用されない（無効化）
		return;
		/*
		// 楽観的UI更新：削除前にスレッド件数を即座に-1
		const parentMessageId = state.currentThread;
		if (parentMessageId) {
			const $parentMessage = $(`.chat-message[data-message-id="${parentMessageId}"]`);
			if ($parentMessage.length && window.LMSChat.messages && typeof window.LMSChat.messages.updateMessageThreadInfo === 'function') {
				const $threadReplyCount = $parentMessage.find('.thread-reply-count');
				const currentCount = parseInt($threadReplyCount.text()) || 0;
				const newCount = Math.max(0, currentCount - 1);
				
				const threadData = {
					total: newCount,
					unread: 0,
					avatars: [],
					optimistic: true // 楽観的更新であることを示すフラグ
				};
				
				window.LMSChat.messages.updateMessageThreadInfo($parentMessage, threadData);
				
				if (newCount === 0) {
					$parentMessage.removeClass('has-thread');
				}
			}
		}
		
		$.ajax({
			url: window.lmsChat?.ajaxurl || '/wp-admin/admin-ajax.php',
			type: 'POST',
			data: {
				action: 'lms_delete_thread_message',
				message_id: messageId,
				nonce: window.lmsChat?.nonce || window.lms_ajax?.nonce || '',
			},
			success: function (response) {
				// 削除成功時は何もしない（楽観的更新がそのまま有効）
			},
			error: function (xhr, status, error) {
				// 削除失敗時のロールバック：件数を+1に戻す
				const parentMessageId = state.currentThread;
				if (parentMessageId) {
					const $parentMessage = $(`.chat-message[data-message-id="${parentMessageId}"]`);
					if ($parentMessage.length && window.LMSChat.messages && typeof window.LMSChat.messages.updateMessageThreadInfo === 'function') {
						const $threadReplyCount = $parentMessage.find('.thread-reply-count');
						const currentCount = parseInt($threadReplyCount.text()) || 0;
						const newCount = currentCount + 1;
						
						const threadData = {
							total: newCount,
							unread: 0,
							avatars: [],
							rollback: true // ロールバックであることを示すフラグ
						};
						
						window.LMSChat.messages.updateMessageThreadInfo($parentMessage, threadData);
						$parentMessage.addClass('has-thread');
					}
				}
				
				// メッセージの削除をキャンセル（フェードインで戻す）
				$message.removeClass('deleting').fadeIn(300);
			},
		});
		$message.addClass('deleting');
		$message.fadeOut(300, function () {
			$(this).remove();
			const remainingMessages = $('.thread-messages .thread-message').length;
			if (remainingMessages === 0) {
				$('.thread-messages').append(
					'<div class="no-messages">このスレッドにはまだ返信がありません</div>'
				);
			}
			const parentMessageId = state.currentThread;
			if (parentMessageId) {
				const $remainingMessages = $('.thread-messages .thread-message:visible').not('.deleting');
				const actualRemainingMessages = $remainingMessages.length;
				if (window.LMSChat.state.threadInfoCache) {
					const existingInfo = window.LMSChat.state.threadInfoCache.get(parentMessageId) || {};
					let latestReplyUser = '';
					let userAvatars = [];
					if (actualRemainingMessages > 0) {
						const $lastMessage = $remainingMessages.last();
						if ($lastMessage.length) {
							const userId = $lastMessage.data('user-id');
							const userName = $lastMessage.find('.user-name').text().trim();
							const userAvatar = $lastMessage.find('.user-avatar img').attr('src') || '';
							latestReplyUser = userName;
							if (
										userAvatar &&
										typeof userAvatar === 'string' &&
										!userAvatar.includes('default-avatar')
									) {
										userAvatars = [{
											avatar_url: userAvatar,
											display_name: userName,
											user_id: userId
										}];
									} else {
										userAvatars = [{
											avatar_url: `/wp-content/uploads/avatars/user-avatar${userId}.jpg`,
											display_name: userName,
											user_id: userId
										}];
									}
						}
					}
					const updatedInfo = {
						...existingInfo,
						total: actualRemainingMessages,
						avatars: userAvatars,
						latest_reply: latestReplyUser,
						timestamp: Date.now(),
					};
					if (updatedInfo.total === 0) {
						window.LMSChat.state.threadInfoCache.delete(parentMessageId);
						if (window.ThreadInfoUpdateManager && window.ThreadInfoUpdateManager.globalLock) {
							window.ThreadInfoUpdateManager.globalLock.add(`force_delete_${parentMessageId}`);
						}
					} else {
						window.LMSChat.state.threadInfoCache.set(parentMessageId, updatedInfo);
					}
					if (
						window.LMSChat.messages &&
						typeof window.LMSChat.messages.updateMessageThreadInfo === 'function'
					) {
						const $parentMessage = $(`.chat-message[data-message-id="${parentMessageId}"]`);
						if ($parentMessage.length) {
							window.LMSChat.messages.updateMessageThreadInfo($parentMessage, updatedInfo);
						}
					}
				}
				
				// サーバーから最新のスレッド情報を取得して更新
				if (typeof refreshThreadInfo === 'function') {
					refreshThreadInfo(parentMessageId);
				} else if (typeof window.refreshThreadInfo === 'function') {
					window.refreshThreadInfo(parentMessageId);
				}
			}
		});
	};
	*/
	const processThreadDeleteMessage = async (messageId, $message, isOptimistic = false) => {
		// この関数は使用されない（無効化）
		return;
		/*
		if (isOptimistic) {
			processOptimisticDelete(messageId, $message);
			return;
		}
		const messageDeleteId = `deleting_${messageId}`;
		if (window.deletingMessages && window.deletingMessages[messageDeleteId]) {
			return;
		}
		if (!window.deletingMessages) {
			window.deletingMessages = {};
		}
		window.deletingMessages[messageDeleteId] = true;
		$message.addClass('deleting');
		$message.fadeOut(300, function () {
			$(this).remove();
			const remainingMessages = $('.thread-messages .thread-message').length;
			if (remainingMessages === 0) {
				$('.thread-messages').append(
					'<div class="no-messages">このスレッドにはまだ返信がありません</div>'
				);
			}
			delete window.deletingMessages[messageDeleteId];
		});
		try {
			const nonce = window.lmsChat && window.lmsChat.nonce ? window.lmsChat.nonce : '';
			if (!nonce) {
				throw new Error('セキュリティトークンが取得できません');
			}
			if (!window.lmsChat || !window.lmsChat.ajaxUrl) {
				throw new Error('AJAX URL not configured');
			}
			let attempts = 0;
			const maxAttempts = 2;
			let response;
			while (attempts < maxAttempts) {
				attempts++;
				try {
					response = await $.ajax({
						url: window.lmsChat.ajaxUrl,
						type: 'POST',
						data: {
							action: 'lms_delete_thread_message',
							message_id: messageId,
							nonce: nonce,
							timestamp: Date.now(),
						},
						timeout: 10000,
						dataType: 'json',
						cache: true,
						processData: true,
						headers: {
							'Cache-Control': 'no-cache',
							'X-Requested-With': 'XMLHttpRequest',
						},
					});
					break;
				} catch (attemptError) {
					if (attempts >= maxAttempts) {
						throw attemptError;
					}
					await new Promise((resolve) => setTimeout(resolve, 1000));
				}
			}
			if (response.success) {
				delete window.deletingMessages[messageDeleteId];
				if (!window.LMSChat.state) {
					window.LMSChat.state = {};
				}
				if (!window.LMSChat.state.deletedMessageIds) {
					window.LMSChat.state.deletedMessageIds = new Set();
				}
				window.LMSChat.state.deletedMessageIds.add(parseInt(messageId));

				// Long Polling 同期イベントをトリガー
				$(document).trigger('thread_message:deleted', {
					messageId: messageId,
					threadId: state.currentThread,
					userId: window.lmsChat.currentUserId,
					timestamp: Date.now(),
					action: 'thread_deleted',
				});

				$(document).trigger('message_deleted', [messageId, true]);
				const parentMessageId = state.currentThread;
				// refreshThreadInfo はthread_message:deletedイベント経由で呼ばれる
				$(document).trigger('thread:message:deleted', [
					{
						parentMessageId: parentMessageId,
						messageId: messageId,
						isCurrentUser: true,
					},
				]);
				$(document).trigger('lms_chat_thread_message_deleted', [
					{
						messageId: messageId,
						parentMessageId: parentMessageId,
						userId: window.lmsChat?.currentUserId || 0,
						channelId: window.LMSChat?.state?.currentChannel || 0,
						timestamp: new Date().toISOString(),
					},
				]);
				if (
					state.currentThread &&
					window.LMSChat.messages &&
					typeof window.LMSChat.messages.queueThreadUpdate === 'function'
				) {
					window.LMSChat.messages.queueThreadUpdate(state.currentThread);
				}
				if (window.LMSChat.utils && window.LMSChat.utils.showSuccessMessage) {
					window.LMSChat.utils.showSuccessMessage('メッセージを削除しました');
				}
			} else {
				delete window.deletingMessages[messageDeleteId];
				if (window.LMSChat.utils && window.LMSChat.utils.showErrorMessage) {
					window.LMSChat.utils.showErrorMessage('削除に失敗しました。ページを更新してください。');
				} else {
				}
			}
		} catch (error) {
			delete window.deletingMessages[messageDeleteId];
			let errorMessage = 'メッセージの削除中にエラーが発生しました。ページを更新してください。';
			let shouldRetry = false;
			if (error.status === 0) {
				errorMessage = 'ネットワーク接続が失われました。ページを再読み込みしてください。';
				shouldRetry = true;
			} else if (error.status === 403) {
				errorMessage = '削除権限がありません。';
			} else if (error.status === 404) {
				errorMessage = 'メッセージが見つかりません。既に削除されている可能性があります。';
				$message.fadeOut(300, function () {
					$(this).remove();
				});
				delete window.deletingMessages[messageDeleteId];
				return;
			} else if (error.status >= 500) {
				errorMessage = 'サーバーエラーが発生しました。しばらく待ってから再度お試しください。';
				shouldRetry = true;
			} else if (error.statusText === 'timeout') {
				errorMessage = 'サーバーの応答がタイムアウトしました。再度お試しください。';
				shouldRetry = true;
			}
			if (window.LMSChat.utils && window.LMSChat.utils.showErrorMessage) {
				window.LMSChat.utils.showErrorMessage(errorMessage);
			} else {
				if (shouldRetry) {
					$message.stop().fadeIn(300);
					delete window.deletingMessages[messageDeleteId];
				} else {
					if (window.LMSChat.utils && window.LMSChat.utils.showErrorMessage) {
						window.LMSChat.utils.showErrorMessage(errorMessage);
					}
				}
			}
		}
	};
	*/
	const showThreadDeleteConfirmDialog = async (messageId, $message, isOptimistic = false) => {
		// この関数は使用されない（無効化）
		return;
		/*

		const messageType = isOptimistic ? '楽観的メッセージ' : 'スレッドメッセージ';
		const messageText = $message.find('.message-text, .message-content').first().text().trim();
		const displayText = messageText.length > 30 ? messageText.slice(0, 30) + '...' : messageText;

		// 楽観的メッセージの場合は即座に確認ダイアログ
		if (isOptimistic) {
			const confirmed = confirm(`この${messageType}を削除しますか？

"${displayText}"`);
			if (confirmed) {
				processThreadDeleteMessage(messageId, $message, isOptimistic);
			}
			return;
		}

		// 通常のスレッドメッセージの場合は返信チェック
		try {
			const response = await $.ajax({
				url:
					window.lmsChat?.ajaxUrl ||
					window.LMSChat?.ajaxUrl ||
					window.ajaxurl ||
					'/wp-admin/admin-ajax.php',
				type: 'POST',
				data: {
					action: 'lms_check_thread_message_replies',
					message_id: messageId,
					nonce: window.lmsChat?.nonce || window.LMSChat?.nonce || window.lms_ajax?.nonce || '',
				},
				timeout: 3000,
			});

			if (response.success && response.data && response.data.has_replies) {
				// 返信がある場合は警告ダイアログ（削除不可）
				const replyCount = response.data.reply_count || 0;
				const warningMessage =
					`⚠️ メッセージ削除の警告 ⚠️

` +
					`対象: "${displayText}"

` +
					`このメッセージには ${replyCount} 件の返信が付いています。

` +
					`返信があるメッセージは削除できません。
` +
					`先に返信を削除してから、このメッセージを削除してください。`;

				alert(warningMessage);
				return;
			}
		} catch (error) {
			// Ajax エラーの場合は通常の削除確認を続行
		}

		// 削除可能な場合は通常の確認ダイアログ
		const confirmed = confirm(`この${messageType}を削除しますか？

"${displayText}"`);

		if (confirmed) {
			processThreadDeleteMessage(messageId, $message, isOptimistic);
		}
		*/
	};
	const showNotLastMessageWarning = () => {
		// 既存のダイアログとイベントハンドラを完全に削除
		$(document).off('click', '.close-warning');
		$(document).off('click', '.not-last-message-warning-overlay');
		$('.not-last-message-warning, .not-last-message-warning-overlay').remove();

		const warningHtml = `
			<div class="not-last-message-warning">
				<p>
					一番新しい最後の返信メッセージのみ削除できます。
				</p>
				<div class="warning-actions">
					<button class="close-warning">OK</button>
				</div>
			</div>
			<div class="not-last-message-warning-overlay"></div>
		`;
		$('body').append(warningHtml);

		// 3秒後の自動削除
		setTimeout(() => {
			$(document).off('click', '.close-warning');
			$(document).off('click', '.not-last-message-warning-overlay');
			$('.not-last-message-warning, .not-last-message-warning-overlay').remove();
		}, 3000);

		// イベントデリゲーションで重複バインドを防ぐ
		$(document).on('click', '.close-warning', function (e) {
			e.preventDefault();
			e.stopPropagation();
			$(document).off('click', '.close-warning');
			$(document).off('click', '.not-last-message-warning-overlay');
			$('.not-last-message-warning, .not-last-message-warning-overlay').remove();
		});

		$(document).on('click', '.not-last-message-warning', function (e) {
			e.stopPropagation();
		});

		$(document).on('click', '.not-last-message-warning-overlay', function (e) {
			e.preventDefault();
			e.stopPropagation();
			$(document).off('click', '.close-warning');
			$(document).off('click', '.not-last-message-warning-overlay');
			$('.not-last-message-warning, .not-last-message-warning-overlay').remove();
		});
	};
	const processParentDeleteMessage = async (messageId, $parentMessage) => {
		try {
			$parentMessage.addClass('deleting');
			const response = await $.ajax({
				url: window.lmsChat.ajaxUrl,
				type: 'POST',
				data: {
					action: 'lms_delete_message',
					nonce: window.lmsChat.nonce,
					message_id: messageId,
				},
			});
			$parentMessage.removeClass('deleting');
			if (response.success) {
				window.forceCloseThread();
				setTimeout(() => {
					const $message = $(`.chat-message[data-message-id="${messageId}"]`);
					const $messageGroup = $message.closest('.message-group');
					$message.fadeOut(300, function () {
						$(this).remove();
						const remainingMessagesCount = $messageGroup.find('.chat-message').length;
						if (remainingMessagesCount === 0) {
							const $dateSeparator = $messageGroup.find('.date-separator');
							$dateSeparator.fadeOut(300, function () {
								$(this).remove();
								if ($messageGroup.children().length === 0) {
									$messageGroup.remove();
								}
							});
						}
					});
				}, 300);
				if (window.LMSChat.state && window.LMSChat.state.deletedMessageIds) {
					window.LMSChat.state.deletedMessageIds.add(messageId);
				}
				$(document).trigger('message_deleted', [messageId, false]);
				if (window.LMSChat.utils && window.LMSChat.utils.showSuccessMessage) {
					window.LMSChat.utils.showSuccessMessage('スレッドを削除しました');
				}
			} else {
				if (window.LMSChat.utils && window.LMSChat.utils.showErrorMessage) {
					window.LMSChat.utils.showErrorMessage('スレッドの削除に失敗しました');
				}
			}
		} catch (error) {
			if (window.LMSChat.utils && window.LMSChat.utils.showErrorMessage) {
				window.LMSChat.utils.showErrorMessage('スレッドの削除中にエラーが発生しました');
			}
		}
	};
	const showParentDeleteConfirmDialog = (messageId, $parentMessage) => {
		const messageText = $parentMessage
			.find('.message-text, .message-content')
			.first()
			.text()
			.trim();
		const displayText = messageText.length > 30 ? messageText.slice(0, 30) + '...' : messageText;

		const confirmed = confirm(`このスレッドとすべての返信を削除しますか？\n\n"${displayText}"`);

		if (confirmed) {
			processParentDeleteMessage(messageId, $parentMessage);
		}
	};
	const showParentMessageDeleteWarning = () => {
		$('.parent-message-delete-warning').remove();
		const warningHtml = `
			<div class="parent-message-delete-warning">
				<p>
					返信メッセージのついたメッセージは削除できません。
				</p>
				<div class="warning-actions">
					<button class="close-warning">OK</button>
				</div>
			</div>
			<div class="parent-message-delete-warning-overlay"></div>
		`;
		$('body').append(warningHtml);
		setTimeout(() => {
			$('.parent-message-delete-warning, .parent-message-delete-warning-overlay').remove();
		}, 3000);
		$('.close-warning, .parent-message-delete-warning-overlay').on('click', function (e) {
			e.preventDefault();
			e.stopPropagation();
			$('.parent-message-delete-warning, .parent-message-delete-warning-overlay').remove();
		});
	};
	if (!window.LMSChat) window.LMSChat = {};
	if (!window.LMSChat.threads) {
		window.LMSChat.threads = {
			preventAutoScroll: false,
		};
	} else {
		window.LMSChat.threads.preventAutoScroll = false;
	}
	const createThreadMessageHtml = (message) => {
		const currentUserIdSource = window.lmsChat?.currentUserId;
		const isCurrentUser =
			message.is_current_user === true || Number(message.user_id) === Number(currentUserIdSource);
		const avatarUrl =
			message.avatar_url || utils.getAssetPath('wp-content/themes/lms/img/default-avatar.png');
		let rawDate = message.created_at || message.message_time || '';
		if (!rawDate && message.formatted_time) {
			const today = new Date();
			const timeParts = message.formatted_time.match(/(\d{1,2}):(\d{2})/);
			if (timeParts) {
				today.setHours(parseInt(timeParts[1]), parseInt(timeParts[2]), 0);
				rawDate = today.toISOString();
			}
		}
		if (!rawDate) {
			rawDate = new Date().toISOString();
		}
		const time = formatMessageTime(rawDate);
		let readStatus = window.LMSChat.getMessageReadStatus
			? window.LMSChat.getMessageReadStatus(message.id, true)
			: null;
		const isNewFromServer =
			(message.is_new === '1' ||
				message.is_new === 1 ||
				message.is_new === true ||
				message.isNewFromServer === true) &&
			!isCurrentUser;
		const isUnread =
			state.unreadThreadMessages && state.unreadThreadMessages.includes(message.id.toString());
		let shouldShowNewMark = false;
		if (!isCurrentUser) {
			if (isNewFromServer) {
				shouldShowNewMark = true;
			} else if (isUnread && readStatus !== 'fully_read') {
				shouldShowNewMark = true;
			}
		}
		if (!isCurrentUser && isNewFromServer && readStatus === 'fully_read') {
			if (window.LMSChat.setMessageReadStatus) {
				window.LMSChat.setMessageReadStatus(message.id, null, true);
			}
			readStatus = null;
			shouldShowNewMark = true;
		}
		if (!shouldShowNewMark && !isCurrentUser) {
		}
		let additionalClasses = '';
		if (readStatus === 'first_view' || readStatus === 'fully_read') {
			additionalClasses += ' viewed-once';
		}
		if (readStatus === 'fully_read') {
			additionalClasses += ' read-completely';
		}
		const newMessageClass = isNewFromServer ? 'new-message new-reply' : '';
		const optimisticClass = message.is_optimistic ? ' optimistic-message' : '';
		let attachmentsHtml = '';
		if (message.attachments && message.attachments.length > 0) {
			if (
				window.LMSChat.uploads &&
				typeof window.LMSChat.uploads.createAttachmentHtml === 'function'
			) {
				attachmentsHtml = `<div class="message-attachments">
					${message.attachments
						.map((attachment) => window.LMSChat.uploads.createAttachmentHtml(attachment))
						.join('')}
				</div>`;
			} else {
				attachmentsHtml = `<div class="message-attachments">`;
				message.attachments.forEach((file) => {
					const fileName = file.file_name || file.name || 'ファイル';
					const fileUrl =
						file.url ||
						(file.file_path
							? `${window.lmsChat.uploadBaseUrl || ''}/chat-files/${file.file_path}`
							: file.id
							? `${window.lmsChat.ajaxUrl}?action=lms_get_file&file_id=${file.id}&nonce=${window.lmsChat.nonce}`
							: '');
					const fileType = file.mime_type || file.file_type || '';
					const fileSize = file.file_size || file.size || 0;
					const formattedSize =
						typeof utils.formatFileSize === 'function'
							? utils.formatFileSize(fileSize)
							: fileSize > 1024
							? Math.round(fileSize / 1024) + ' KB'
							: fileSize + ' B';
					const isImage =
						fileType &&
						(fileType.startsWith('image/') ||
							['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'].includes(
								fileName.split('.').pop().toLowerCase()
							));
					let thumbnailUrl = '';
					if (isImage) {
						if (file.thumbnail) {
							thumbnailUrl = file.thumbnail.startsWith('http')
								? file.thumbnail
								: `${window.lmsChat.uploadBaseUrl || ''}/chat-files/${file.thumbnail}`;
						} else {
							thumbnailUrl = fileUrl;
						}
					}
					const previewHtml = isImage
						? `<img src="${thumbnailUrl}" alt="${utils.escapeHtml(fileName)}">`
						: `<img src="${utils.getAssetPath(
								'wp-content/themes/lms/img/icon-file.svg'
						  )}" class="file-icon" alt="${fileType || '不明なファイル形式'}">`;
					attachmentsHtml += `
						<div class="attachment-item">
							<div class="attachment-preview">
								${previewHtml}
								<a href="${fileUrl}" class="attachment-download" download="${utils.escapeHtml(
						fileName
					)}" target="_blank">
									<img src="${utils.getAssetPath('wp-content/themes/lms/img/icon-download.svg')}" alt="ダウンロード">
								</a>
							</div>
							<div class="attachment-info">
								<div class="attachment-name">${utils.escapeHtml(fileName)}</div>
								<div class="attachment-size">${formattedSize}</div>
							</div>
						</div>
					`;
				});
				attachmentsHtml += `</div>`;
			}
		}
		let reactionsHtml = '';
		if (message.reactions && message.reactions.length > 0) {
			if (
				window.LMSChat.reactions &&
				typeof window.LMSChat.reactions.createReactionsHtml === 'function'
			) {
				reactionsHtml = window.LMSChat.reactions.createReactionsHtml(message.reactions);
			} else if (
				window.LMSChat.reactionUI &&
				typeof window.LMSChat.reactionUI.createReactionsHtml === 'function'
			) {
				reactionsHtml = window.LMSChat.reactionUI.createReactionsHtml(message.reactions);
			} else {
				reactionsHtml = '<div class="message-reactions" data-reactions-hydrated="1">';
				const reactionCounts = {};
				const currentUserId = parseInt(window.lmsChat.currentUserId);
				const userReactions = {};
				message.reactions.forEach((reaction) => {
					const emoji = reaction.reaction;
					if (!reactionCounts[emoji]) {
						reactionCounts[emoji] = 0;
						userReactions[emoji] = [];
					}
					reactionCounts[emoji]++;
					userReactions[emoji].push(parseInt(reaction.user_id));
				});
				Object.keys(reactionCounts).forEach((emoji) => {
					const count = reactionCounts[emoji];
					const hasUserReacted = userReactions[emoji].includes(currentUserId);
					reactionsHtml += `
						<div class="reaction-item ${hasUserReacted ? 'user-reacted' : ''}" data-emoji="${emoji}">
							<span class="emoji">${emoji}</span>
							<span class="count">${count}</span>
						</div>
					`;
				});
				reactionsHtml += '</div>';
			}
		}
		if (reactionsHtml) {
			if (!reactionsHtml.includes('data-reactions-hydrated')) {
				reactionsHtml = reactionsHtml.replace(
					/<div class="message-reactions([^>]*)>/,
					'<div class="message-reactions$1" data-reactions-hydrated="1">'
				);
			}
		} else {
			reactionsHtml = '<div class="message-reactions" data-reactions-hydrated="0"></div>';
		}
		return `<div class="thread-message ${
			isCurrentUser ? 'current-user' : ''
		} ${newMessageClass} ${additionalClasses}${optimisticClass}" data-message-id="${
			message.id
		}" data-user-id="${message.user_id || window.lmsChat.currentUserId}" data-parent-message-id="${
			message.parent_message_id || message.parentMessageId || ''
		}" data-read-status="${readStatus || 'null'}">
			<div class="message-header">
				<div class="message-meta">
					<span class="message-time" data-timestamp="${rawDate}">${time}</span>
					<span class="user-name ${isCurrentUser ? 'current-user-name' : 'other-user-name'}">
						${utils.escapeHtml(message.display_name)}
					</span>
					${shouldShowNewMark ? '<span class="new-mark">New</span>' : ''}
				</div>
			</div>
			<div class="message-content">
				<div class="message-text">
					${utils.linkifyUrls(utils.escapeHtml(message.message))}
				</div>
				${attachmentsHtml}
				<div class="message-actions">
					<button class="action-button add-reaction" aria-label="リアクションを追加">
						<img src="${utils.getAssetPath(
							'wp-content/themes/lms/img/icon-emoji.svg'
						)}" alt="絵文字" width="20" height="20">
					</button>
					${
						isCurrentUser
							? `
					<button class="action-button delete-thread-message" aria-label="メッセージを削除">
						<svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
							<path d="M6 18L18 6M6 6l12 12" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
						</svg>
					</button>
				`
							: ''
					}
				</div>
			</div>
			${reactionsHtml}
		</div>`;
	};
	const forceUpdateTimestamps = () => {
		const $timeElements = $(
			'.thread-message .message-time, .thread-parent-user .message-time, .message-time'
		);
		if ($timeElements.length === 0) {
			return;
		}
		$timeElements.each(function (index) {
			const $this = $(this);
			const currentText = $this.text().trim();
			const timePattern = /^(\d{1,2}):(\d{2})$/;
			if (timePattern.test(currentText)) {
				const today = new Date();
				const [_, hours, minutes] = currentText.match(timePattern);
				today.setHours(hours, minutes, 0, 0);
				const timestamp = today.toISOString();
				$this.attr('data-timestamp', timestamp);
				const formatted = formatMessageTime(timestamp);
				$this.text(formatted);
			}
		});
	};
	const openThread = async (messageId) => {
		try {
			// closingクラスを即座に削除（アニメーション中でも開けるように）
			$('.thread-panel').removeClass('closing');

			// パネルが実際に表示されている場合のみ、同じスレッドのチェックを行う
			const isPanelActuallyOpen =
				$('.thread-panel').hasClass('open') &&
				$('.thread-panel').is(':visible') &&
				$('.thread-panel').css('display') !== 'none';

			// 同じスレッドが既に完全に開いている場合のみスキップ
			if (state.currentThread === messageId && isPanelActuallyOpen) {
				return;
			}

			// 非同期で未読カウントを更新（スレッドの開く処理をブロックしない）
			$.ajax({
				url: window.lmsChat?.ajaxUrl || '/wp-admin/admin-ajax.php',
				type: 'POST',
				data: {
					action: 'lms_get_unread_count',
					nonce: window.lmsChat?.nonce,
				},
				timeout: 1000, // タイムアウトを短縮
				success: function(response) {
					if (response && response.success && response.data) {
						if (window.LMSChat && window.LMSChat.state) {
							window.LMSChat.state.unreadCounts = response.data.channels || response.data || {};
						}
					}
				}
			});
			// スレッド状態を即座に更新
			state.currentThread = messageId;
			state.lastThreadMessageId = 0;
			lastMessageId = 0;
			state.unreadThreadMessages = [];

			// スレッドパネルを即座に表示
			const $threadPanel = $('.thread-panel');
			$threadPanel.show().css({
				display: 'block',
				right: '',
				opacity: '',
				visibility: '',
				transform: '',
			});
			$threadPanel.removeClass('closing').addClass('open');
			$threadPanel.attr('data-current-thread-id', messageId);
			$('body').addClass('thread-open');

			// イベントを即座にトリガー
			$(document).trigger('thread_panel_opened', [messageId]);
			setupThreadEventListeners();

			const $parentMessage = $(`.chat-message[data-message-id="${messageId}"]`);
			if ($parentMessage.length) {
				$parentMessage.find('.message-content .unread-badge.thread-force-badge').remove();
				$parentMessage
					.find('.parent-message-reactions .unread-badge.thread-force-badge')
					.remove();
				$parentMessage.find('.message-actions .unread-badge.thread-force-badge').remove();
				const $threadInfo = $parentMessage.find('.thread-info');
				if ($threadInfo.length) {
					const $countEl = $threadInfo.find('.thread-count, .thread-reply-count');
					const countText = $countEl.text();
					const matches = countText.match(/(\d+)/);
					const currentCount = matches ? parseInt(matches[1], 10) : 0;
					if (!window.LMSChat.state.threadInfoCache) {
						window.LMSChat.state.threadInfoCache = new Map();
					}
					const existingInfo = window.LMSChat.state.threadInfoCache.get(messageId) || {};
					const threadInfo = {
						total: Math.max(currentCount, existingInfo.total || 0),
						unread: existingInfo.unread || 0,
						avatars: existingInfo.avatars || [],
						latest_reply: existingInfo.latest_reply || '',
						timestamp: Date.now(),
					};
					window.LMSChat.state.threadInfoCache.set(messageId, threadInfo);
				}
			}
			$(document).trigger('thread:opened', [messageId]);
			if (window.threadLoadRetryTimer) {
				clearTimeout(window.threadLoadRetryTimer);
				window.threadLoadRetryTimer = null;
			}
			// 10ms後にバッジを一時的に非表示（要求がある場合のみ）
			if (window.LMSChatBadgeManager) {
				window.LMSChatBadgeManager.protectionUntil = Date.now() + 500;
			}
			const $threadMessages = $('.thread-messages');
			const cachedMessages = window.LMSChat.cache
				? window.LMSChat.cache.getThreadMessagesCache(messageId, 1)
				: null;
			if (cachedMessages && cachedMessages.messages && cachedMessages.messages.length > 0) {
				$threadMessages.empty();
				cachedMessages.messages.forEach((message) => {
					appendThreadMessage(message);
				});
				requestAnimationFrame(() => {
					scrollThreadToBottom();
				});
			} else {
				$threadMessages.html(`
					<div class="thread-loading-subtle">
						<div class="loading-dots">
							<span></span>
							<span></span>
							<span></span>
						</div>
						<span class="loading-text">メッセージを読み込み中...</span>
					</div>
				`);
			}
			const loadMessagesPromise = loadThreadMessages(messageId).catch((error) => {
				return { success: false, error: error };
			});
			const $message = $(`.chat-message[data-message-id="${messageId}"]`);
			if (!$message.length) {
				return;
			}
			// refreshThreadInfo呼び出しを削除（メインチャットのDOM更新によるスクロール問題を回避）
			// if (
			// 	window.LMSChat.messages &&
			// 	typeof window.LMSChat.messages.updateThreadInfo === 'function'
			// ) {
			// 	window.LMSChat.messages.updateThreadInfo(messageId);
			// }
			// refreshThreadInfo(messageId);
			// setTimeout(() => {
			// 	if (
			// 		window.LMSChat.messages &&
			// 		typeof window.LMSChat.messages.updateThreadInfo === 'function'
			// 	) {
			// 		window.LMSChat.messages.updateThreadInfo(messageId);
			// 	}
			// 	refreshThreadInfo(messageId);
			// }, 120);
			// setTimeout(() => {
			// 	refreshThreadInfo(messageId);
			// }, 1000);
			const readStatusPromise = new Promise((resolve) => {
				const timeoutId = setTimeout(() => {
					resolve({ success: false, data: { unread_messages: [] } });
				}, 2000);
				const nonce = window.lmsChat && window.lmsChat.nonce ? window.lmsChat.nonce : '';
				const ajaxUrl = window.lmsChat && window.lmsChat.ajaxUrl ? window.lmsChat.ajaxUrl : '';
				if (!nonce || !ajaxUrl) {
					clearTimeout(timeoutId);
					resolve({ success: false, data: { unread_messages: [] } });
					return;
				}
				$.ajax({
					url: ajaxUrl,
					type: 'GET',
					data: {
						action: 'lms_get_thread_read_status',
						parent_message_id: messageId,
						nonce: nonce,
					},
					success: (response) => {
						clearTimeout(timeoutId);
						resolve(response);
					},
					error: () => {
						clearTimeout(timeoutId);
						resolve({ success: false, data: { unread_messages: [] } });
					},
				});
			});
			try {
				const readStatusResponse = await readStatusPromise;
				if (readStatusResponse.success) {
					state.unreadThreadMessages = readStatusResponse.data.unread_messages || [];
				}
			} catch (error) {}
			let messageTimestamp = $message.data('timestamp');
			const parentMessage = {
				id: messageId,
				display_name: $message.find('.user-name').text().trim(),
				message: $message.find('.message-text').html(),
				formatted_time: messageTimestamp
					? formatMessageTime(messageTimestamp)
					: $message.find('.message-time').text().trim(),
				reactions: $message.find('.message-reactions').html() || '',
				isCurrentUser: $message.hasClass('current-user'),
				attachments: $message.find('.message-attachments').html() || '',
			};
			const parentReactions = $message.find('.message-reactions').html() || '';
			$('.parent-message')
				.attr('data-message-id', messageId)
				.addClass(parentMessage.isCurrentUser ? 'current-user' : '').html(`
				<div class="parent-message-header">
					<div class="message-header-left">
						<span class="message-time">${parentMessage.formatted_time}</span>
						<span class="user-name ${parentMessage.isCurrentUser ? 'current-user-name' : ''}">
							${utils.escapeHtml(parentMessage.display_name)}
						</span>
					</div>
					<div class="header-actions">
						<div class="message-actions">
							<button class="action-button add-reaction" aria-label="リアクションを追加" data-message-id="${messageId}">
								<img src="${utils.getAssetPath(
									'wp-content/themes/lms/img/icon-emoji.svg'
								)}" alt="絵文字" width="20" height="20">
							</button>
							${
								parentMessage.isCurrentUser
									? `
							<button class="action-button delete-parent-message" aria-label="メッセージを削除" data-message-id="${messageId}">
								<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
									<path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
								</svg>
							</button>
							`
									: ''
							}
						</div>
						<div class="close-thread-btn" title="スレッドを閉じる">&times;</div>
					</div>
				</div>
				<div class="parent-message-body">
					<div class="message-content">
						<div class="message-text">${parentMessage.message}</div>
						${parentMessage.attachments}
					</div>
				</div>
			`);
			if (parentReactions) {
				$('.parent-message-reactions').remove();
				$(
					'<div class="parent-message-reactions" data-message-id="' +
						messageId +
						'">' +
						parentReactions +
						'</div>'
				).insertAfter('.parent-message');
			} else {
				$('.parent-message-reactions').remove();
			}
			setTimeout(() => {
				if (
					window.LMSChat.reactionActions &&
					window.LMSChat.reactionActions.refreshParentMessageReactions
				) {
					window.LMSChat.reactionActions.refreshParentMessageReactions(messageId, true);
				}
			}, 100);
			const $parentMessageBody = $('.parent-message-body');
			if ($parentMessageBody.length) {
				$parentMessageBody.removeClass('scrollable scrolling');
				const initialCheck = () => {
					const contentHeight = $parentMessageBody.prop('scrollHeight');
					const visibleHeight = $parentMessageBody.height();
					const threshold = 20;
					const needsScroll = contentHeight > visibleHeight + threshold;
					if (needsScroll) {
						if (!$parentMessageBody.hasClass('scrollable')) {
							$parentMessageBody.addClass('scrollable');
							setupParentMessageScrollDetection($parentMessageBody);
						}
					} else {
						if (
							$parentMessageBody.hasClass('scrollable') ||
							$parentMessageBody.hasClass('scrolling')
						) {
							$parentMessageBody.removeClass('scrollable scrolling');
							$parentMessageBody.off('scroll.scrollDetection touchmove.scrollDetection');
							$parentMessageBody.removeData('scroll-detection-setup');
						}
					}
				};
				initialCheck();
				setTimeout(initialCheck, 300);
				setTimeout(initialCheck, 800);
				setTimeout(initialCheck, 1500);
			}
			markThreadAsRead(messageId);
			setupThreadScroll();
			const ensureScrollToBottom = () => {
				if (window.UnifiedScrollManager) {
					window.UnifiedScrollManager.scrollThreadToBottom(0, false);
				} else {
					const $threadMessages = $('.thread-messages');
					if ($threadMessages.length) {
						$threadMessages.scrollTop($threadMessages[0].scrollHeight + 300);
					}
				}
			};
			setTimeout(ensureScrollToBottom, 300);
			setTimeout(ensureScrollToBottom, 600);
			setTimeout(ensureScrollToBottom, 1000);
			setTimeout(ensureScrollToBottom, 1500);
			setTimeout(() => {
				$('.thread-input').focus();
			}, 800);
			$(document).trigger('thread:opened', [messageId]);
			setTimeout(() => {
				if (
					window.LMSChat.reactions &&
					typeof window.LMSChat.reactions.loadReactionsForThread === 'function'
				) {
					window.LMSChat.reactions.loadReactionsForThread(messageId);
				}
				if (
					window.LMSChat.reactions &&
					typeof window.LMSChat.reactions.triggerImmediatePolling === 'function'
				) {
					window.LMSChat.reactions.triggerImmediatePolling();
				}
			}, 500);
			setTimeout(() => {
				// バッジ機能の復元（変数が定義されている場合のみ）
				if (typeof originalUpdateBadge !== 'undefined') {
					window.updateChannelBadge = originalUpdateBadge;
				}
				if (typeof originalUpdateDisplay !== 'undefined') {
					window.updateChannelBadgeDisplay = originalUpdateDisplay;
				}
				if (typeof originalUpdateForce !== 'undefined') {
					window.updateChannelBadgeDisplayForce = originalUpdateForce;
				}

				$('[data-temp-hidden="true"]').removeAttr('data-temp-hidden');
				if (
					typeof savedUnreadCounts !== 'undefined' &&
					savedUnreadCounts &&
					window.LMSChat &&
					window.LMSChat.state
				) {
					window.LMSChat.state.unreadCounts = savedUnreadCounts;
				}
			}, 3000);

			// [STEP2-FIX] Long Pollingシステムに必要なスレッド開始イベントを発火
			$(document).trigger('lms_thread_opened', [messageId]);
			// Thread opened event triggered
		} catch (error) {
			console.error('Error in openThread:', error);
		}
	};
	const updateThreadInfo = (parentMessage) => {
		try {
			if (!parentMessage) {
				return;
			}
			const $threadTitle = $('#thread-title');
			const $threadParent = $('#thread-parent-message');
			if ($threadTitle.length === 0 || $threadParent.length === 0) {
				return;
			}
			$threadTitle.text(parentMessage.display_name + 'の返信スレッド');
			const rawParentDate = parentMessage.created_at || parentMessage.message_time || '';
			const formattedTime = rawParentDate ? formatMessageTime(rawParentDate) : '';
			const currentUserId = Number(window.lmsChat.currentUserId);
			const messageUserId = Number(parentMessage.user_id);
			const isCurrentUser = currentUserId === messageUserId;
			const parentHtml = `
				<div class="parent-message-header">
					<div class="message-header-left">
						<span class="message-time">${formattedTime}</span>
						<span class="user-name ${isCurrentUser ? 'current-user-name' : ''}">
							${utils.escapeHtml(parentMessage.display_name)}
						</span>
					</div>
					<div class="header-actions">
						<div class="message-actions">
							<button class="action-button add-reaction" aria-label="リアクションを追加" data-message-id="${
								parentMessage.id
							}">
								<img src="${utils.getAssetPath(
									'wp-content/themes/lms/img/icon-emoji.svg'
								)}" alt="絵文字" width="20" height="20">
							</button>
							${
								isCurrentUser
									? `
							<button class="action-button delete-parent-message" aria-label="メッセージを削除" data-message-id="${parentMessage.id}">
								<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
									<path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path>
								</svg>
							</button>
							`
									: ''
							}
						</div>
						<div class="close-thread-btn" title="スレッドを閉じる">&times;</div>
					</div>
				</div>
				<div class="parent-message-body">
					<div class="message-content">
						<div class="message-text">${utils.linkifyUrls(utils.escapeHtml(parentMessage.message))}</div>
					</div>
				</div>
			`;
			$threadParent
				.removeClass('current-user no-reactions')
				.addClass(isCurrentUser ? 'current-user' : '')
				.addClass('no-reactions')
				.html(parentHtml);
		} catch (error) {}
	};
	const loadThreadMessages = async (messageId, page = 1, preserveScroll = false) => {
		if (!$('#load-thread-badge-hide').length) {
			$('<style>')
				.prop('type', 'text/css')
				.prop('id', 'load-thread-badge-hide')
				.html('.unread-badge { display: none !important; }')
				.appendTo('head');
		}
		if (window.LMSChatBadgeManager) {
			window.LMSChatBadgeManager.protectionUntil = Date.now() + 2000;
		}
		setTimeout(() => {
			$('#load-thread-badge-hide').remove();
		}, 2000);
		if (state.currentThread === messageId && state.currentThreadAjaxRequest) {
			return;
		}
		if (state.currentThreadAjaxRequest) {
			state.currentThreadAjaxRequest.abort();
			state.currentThreadAjaxRequest = null;
		}
		state.threadApiErrorCount = 0;
		const $threadMessages = $('.thread-messages');
		const scrollPosition = $threadMessages.scrollTop();
		const isScrolledUp = scrollPosition > 0;
		const maxRetries = 3;
		let retryCount = 0;
		const cachedMessages = window.LMSChat.cache
			? window.LMSChat.cache.getThreadMessagesCache(messageId, page)
			: null;
		let hasDisplayedFromCache = false;
		if (cachedMessages) {
			let messages = cachedMessages.messages || [];
			const pagination = cachedMessages.pagination;
			messages = messages.filter((message) => {
				if (
					window.LMSChat.state &&
					window.LMSChat.state.deletedMessageIds &&
					window.LMSChat.state.deletedMessageIds.has(parseInt(message.id))
				) {
					return false;
				}
				return true;
			});
			if (messages && messages.length > 0) {
				state.loadingPage = page;
				hasDisplayedFromCache = true;
				$('.thread-loading-subtle').remove();
				$threadMessages.empty();
				messages.forEach((message) => {
					appendThreadMessage(message);
				});
				let lastId = 0;
				messages.forEach((message) => {
					const messageId = parseInt(message.id, 10);
					if (messageId > lastId) {
						lastId = messageId;
					}
				});
				if (lastId > 0) {
					lastMessageId = lastId;
					state.lastThreadMessageId = lastId;
				}
				if (preserveScroll && isScrolledUp) {
					$threadMessages.scrollTop(scrollPosition);
				} else {
					scrollThreadToBottom();
				}
				markThreadAsRead(messageId);
				state.currentThread = messageId;
				state.currentPage = page;
				state.lastPage = pagination ? pagination.lastPage : 1;
			} else {
			}
		}
		try {
			const nonce = window.lmsChat && window.lmsChat.nonce ? window.lmsChat.nonce : '';
			const ajaxUrl = window.lmsChat && window.lmsChat.ajaxUrl ? window.lmsChat.ajaxUrl : '';
			if (!nonce || !ajaxUrl) {
				throw new Error('必要な設定情報（nonceまたはajaxUrl）が見つかりません');
			}
			let retries = 0;
			const maxRetries = 0;
			let response = null;
			while (retries <= maxRetries) {
				try {
					if (retries > 0) {
					}
					let ajaxAborted = false;
					try {
						response = await new Promise((resolve, reject) => {
							const timeoutId = setTimeout(() => {
								ajaxAborted = true;
								if (ajaxRequest && ajaxRequest.readyState < 4) {
									ajaxRequest.abort();
									reject({
										status: 'client_timeout',
										error: 'クライアント側のタイムアウト - 応答が遅すぎます',
									});
								}
							}, 3000); // さらに3秒に短縮（高速化）
							const ajaxRequest = $.ajax({
								url: ajaxUrl,
								type: 'GET',
								data: {
									action: 'lms_get_thread_messages',
									parent_message_id: messageId,
									page: page,
									nonce: nonce,
									// 高速化オプション追加
									fast_mode: true,
									minimal_data: true,
								},
								cache: true, // キャッシュ有効化で高速化
								timeout: 4000, // 4秒に短縮（さらなる高速化）
								success: function (data) {
									clearTimeout(timeoutId);
									state.currentThreadAjaxRequest = null;
									resolve(data);
								},
								error: function (xhr, status, error) {
									clearTimeout(timeoutId);
									state.currentThreadAjaxRequest = null;
									if (status === 'abort') {
										reject({ xhr, status, error: 'Cancelled' });
									} else {
										reject({ xhr, status, error: error || status || 'Unknown Error' });
									}
								},
							});
							state.currentThreadAjaxRequest = ajaxRequest;
							window.lastAjaxRequest = ajaxRequest;
						});
					} catch (ajaxError) {
						if (ajaxAborted) {
						}
						throw ajaxError;
					}
					break;
				} catch (error) {
					if (error.status === 'abort' || error.error === 'Cancelled') {
						if (window.LMSChat.cache) {
							const cachedMessages = window.LMSChat.cache.getThreadMessagesCache(messageId, page);
							if (cachedMessages && cachedMessages.messages && cachedMessages.messages.length > 0) {
								$threadMessages.empty();
								cachedMessages.messages.forEach((message) => {
									if (
										!window.LMSChat.state?.deletedMessageIds ||
										!window.LMSChat.state.deletedMessageIds.has(parseInt(message.id))
									) {
										appendThreadMessage(message);
									}
								});
								if (!preserveScroll || !isScrolledUp) {
									$threadMessages.scrollTop($threadMessages[0].scrollHeight);
								}
							} else {
								$threadMessages.html('<div class="no-messages">メッセージを読み込み中...</div>');
							}
						}
						return;
					}
					retries++;
					if (retries > maxRetries) {
						$('.thread-messages .loading-indicator').remove();
						$('.thread-messages .thread-loading-subtle').remove();
						$threadMessages.empty();
						const lastResortCache = window.LMSChat.cache
							? window.LMSChat.cache.getThreadMessagesCache(messageId, page)
							: null;
						if (
							lastResortCache &&
							lastResortCache.messages &&
							lastResortCache.messages.length > 0
						) {
							try {
								lastResortCache.messages.forEach((message) => {
									appendThreadMessage(message);
								});
								$threadMessages.append(
									'<div class="cache-restored-notice">オフラインモードで表示中（キャッシュから復元）</div>'
								);
							} catch (cacheError) {
								$threadMessages.append(
									'<div class="thread-connection-retry">接続中...<span class="loading-dots"><span>.</span><span>.</span><span>.</span></span></div>'
								);
							}
						} else {
							$threadMessages.html(`
								<div class="no-messages">
									<p>メッセージがありません</p>
								</div>
							`);
							setTimeout(() => {
								if (state.currentThread === messageId) {
									state.threadApiErrorCount = 0;
									loadThreadMessages(messageId, page, preserveScroll);
								}
							}, 5000);
						}
						state.currentThread = messageId;
						state.currentPage = page;
						try {
							markThreadAsRead(messageId);
						} catch (readError) {}
						return false;
					}
					const isNetworkError = !error.status || error.status === 0;
					const isServerError = error.status >= 500;
					const isTimeout =
						error.statusText === 'timeout' || (error.xhr && error.xhr.statusText === 'timeout');
					if (!isNetworkError && !isServerError && !isTimeout) {
						throw error;
					}
					const retryDelay = 300 * retries;
					await new Promise((resolve) => setTimeout(resolve, retryDelay));
				}
			}
			$('.thread-messages .connection-error').fadeOut(300, function () {
				$(this).remove();
			});
			$('.thread-messages .thread-connection-retry').remove();
			$('.thread-messages .thread-loading-subtle').remove();
			if (response && response.success === true) {
				const data = response.data;
				const messages = data.messages || [];
				const pagination = data.pagination;
				const parentMessage = data.parent_message;
				if (messages.length === 0) {
					if (window.LMSChatBadgeManager) {
						window.LMSChatBadgeManager.protectionUntil = Date.now() + 1000;
					}
					$('.unread-badge').text('').hide();
					$threadMessages.html(
						'<div class="no-messages">このスレッドにはまだ返信がありません</div>'
					);
					state.currentThread = messageId;
					state.currentPage = page;
					return;
				}
				if (parentMessage) {
					updateThreadInfo(parentMessage);
				}
				if (Array.isArray(messages)) {
					const filteredMessages = messages.filter((message) => {
						if (
							window.LMSChat.state &&
							window.LMSChat.state.deletedMessageIds &&
							window.LMSChat.state.deletedMessageIds.has(parseInt(message.id))
						) {
							return false;
						}
						return true;
					});
					window.LMSChat.cache.setThreadMessagesCache(messageId, page, {
						messages: messages,
						pagination: pagination,
					});
					state.loadingPage = page;
					if (hasDisplayedFromCache) {
						const existingMessageIds = Array.from($threadMessages.find('.thread-message')).map(
							(el) => $(el).data('message-id')
						);
						const newMessages = filteredMessages.filter(
							(msg) => !existingMessageIds.includes(parseInt(msg.id))
						);
						if (newMessages.length > 0) {
							newMessages.forEach((message) => {
								appendThreadMessage(message);
							});
						}
					} else {
						$threadMessages.empty();
						filteredMessages.forEach((message) => {
							appendThreadMessage(message);
						});
					}
					$threadMessages.find('.thread-loading-subtle').remove();
					$('.thread-loading-subtle').remove();
					let lastId = 0;
					filteredMessages.forEach((message) => {
						const messageId = parseInt(message.id, 10);
						if (messageId > lastId) {
							lastId = messageId;
						}
					});
					if (lastId > 0) {
						lastMessageId = lastId;
						state.lastThreadMessageId = lastId;
					}
					if (filteredMessages.length === 0 && messages.length === 0) {
						$threadMessages.find('.thread-loading-subtle').remove();
						$threadMessages.append(
							'<div class="no-messages">このスレッドにはまだ返信がありません</div>'
						);
					} else if (filteredMessages.length === 0 && messages.length > 0) {
						$threadMessages.append(
							'<div class="filtered-messages-notice">一部のメッセージは表示できません</div>'
						);
					}
					if (preserveScroll && isScrolledUp) {
						$threadMessages.scrollTop(scrollPosition);
					} else {
						scrollThreadToBottom();
					}
					markThreadAsRead(messageId);
					state.currentThread = messageId;
					state.currentPage = page;

					// スレッドリアクション同期のためのLong Polling接続を開始
					try {
						const currentChannelId =
							window.LMSChat && window.LMSChat.state && window.LMSChat.state.currentChannel
								? window.LMSChat.state.currentChannel
								: null;

						// Long Polling connection attempt

						if (currentChannelId && messageId) {
							// 基本Long Polling接続（確実に動作）
							const longPollAPI = window.LMSLongPoll || window.LMSChat?.LongPoll;
							if (longPollAPI && typeof longPollAPI.connect === 'function') {
								setTimeout(() => {
									try {
										longPollAPI.connect(currentChannelId, messageId);
									} catch (connectError) {
										// エラーは静かに処理
									}
								}, 100);
							}

							// 統合Long Pollingへチャンネルとスレッド情報を通知
							try {
								if (window.UnifiedLongPollClient) {
									window.UnifiedLongPollClient.currentChannelId = currentChannelId;
									window.UnifiedLongPollClient.currentThreadId = messageId;
								}
							} catch (unifiedError) {
								// エラーは静かに処理
							}
						}
					} catch (longPollError) {
						// エラーは静かに処理
					}
					state.lastPage = pagination ? pagination.lastPage : 1;
					refreshThreadInfo(messageId);
				} else {
					if (parentMessage) {
						updateThreadInfo(parentMessage);
					}
					$threadMessages
						.empty()
						.append('<div class="no-messages">このスレッドにはまだ返信がありません</div>');
					state.currentThread = messageId;
					state.currentPage = 1;
					state.lastPage = 1;

					// スレッドリアクション同期のためのLong Polling接続を開始（空のスレッド）
					try {
						const currentChannelId =
							window.LMSChat && window.LMSChat.state && window.LMSChat.state.currentChannel
								? window.LMSChat.state.currentChannel
								: null;

						if (currentChannelId && messageId) {
							// 基本Long Polling接続（確実に動作）
							const longPollAPI = window.LMSLongPoll || window.LMSChat?.LongPoll;
							if (longPollAPI && typeof longPollAPI.connect === 'function') {
								setTimeout(() => {
									try {
										longPollAPI.connect(currentChannelId, messageId);
									} catch (connectError) {
										// エラーは静かに処理
									}
								}, 100);
							}

							// 統合Long Pollingへチャンネルとスレッド情報を通知
							try {
								if (window.UnifiedLongPollClient) {
									window.UnifiedLongPollClient.currentChannelId = currentChannelId;
									window.UnifiedLongPollClient.currentThreadId = messageId;
								}
							} catch (unifiedError) {
								// エラーは静かに処理
							}
						}
					} catch (longPollError) {
						// エラーは静かに処理
					}

					refreshThreadInfo(messageId);
				}
			} else {
				$threadMessages
					.empty()
					.append(
						'<div class="error-message">スレッドメッセージの読み込みに失敗しました。再試行してください。</div>'
					);
			}
		} catch (error) {
			$threadMessages.empty().append(
				`<div class="error-message">
					<p>スレッドメッセージの読み込みに失敗しました。</p>
					<button class="retry-button" data-parent-id="${messageId}">再試行</button>
				</div>`
			);
			$threadMessages.find('.retry-button').on('click', function () {
				const parentId = $(this).data('parent-id');
				loadThreadMessages(parentId, 1, false);
			});
			if (window.LMSChat.cache) {
				const cachedMessages = window.LMSChat.cache.getThreadMessagesCache(messageId, page);
				if (cachedMessages && cachedMessages.messages && cachedMessages.messages.length > 0) {
					$threadMessages.append(`
						<div class="cache-restored-notice">
							<p>キャッシュからメッセージを復元しました</p>
						</div>
					`);
					cachedMessages.messages.forEach((message) => {
						if (
							window.LMSChat.state &&
							window.LMSChat.state.deletedMessageIds &&
							window.LMSChat.state.deletedMessageIds.has(parseInt(message.id))
						) {
							return;
						}
						appendThreadMessage(message);
					});
					if (preserveScroll && isScrolledUp) {
						$threadMessages.scrollTop(scrollPosition);
					} else {
						scrollThreadToBottom();
					}
					markThreadAsRead(messageId);
				}
			}
		} finally {
			state.currentThreadAjaxRequest = null;
		}
	};
	const appendThreadMessage = (message, options = {}) => {
		const $threadMessages = $('.thread-messages');
		if (!$threadMessages.length) {
			return false;
		}
		if (
			window.LMSChat.state &&
			window.LMSChat.state.deletedMessageIds &&
			window.LMSChat.state.deletedMessageIds.has(parseInt(message.id))
		) {
			return false;
		}
		$threadMessages.find('.no-messages').remove();
		$threadMessages.find('.thread-loading-subtle').remove();
		$threadMessages.find('.error-message').remove();
		const currentUserIdSource = window.lmsChat?.currentUserId;
		const isCurrentUser =
			message.is_current_user === true || Number(message.user_id) === Number(currentUserIdSource);
		const existingMessage = $threadMessages.find(
			`.thread-message[data-message-id="${message.id}"]`
		);
		if (existingMessage.length > 0) {
			return false;
		}
		const messageHtml = createThreadMessageHtml(message);
		if (!messageHtml || messageHtml.trim() === '') {
			return false;
		}
		const fragment = document.createDocumentFragment();
		const tempDiv = document.createElement('div');
		tempDiv.innerHTML = messageHtml;
		while (tempDiv.firstChild) {
			fragment.appendChild(tempDiv.firstChild);
		}
		$threadMessages[0].appendChild(fragment);
		updateThreadTimestamps();
		const $newMessage = $(`.thread-message[data-message-id="${message.id}"]`);
		if (message.is_optimistic) {
			$newMessage.attr('data-optimistic', 'true');
		}
		const existingReadStatus = window.LMSChat.getMessageReadStatus
			? window.LMSChat.getMessageReadStatus(message.id, true)
			: null;
		if (!isCurrentUser) {
			if (existingReadStatus === 'fully_read') {
				message.is_new = false;
			} else if (
				existingReadStatus === null &&
				(message.is_new === '1' || message.is_new === 1 || message.is_new === true)
			) {
				if (window.LMSChat.markMessageAsReadInDatabase) {
					window.LMSChat.markMessageAsReadInDatabase(message.id, true);
				}
				if (window.LMSChat.setMessageReadStatus) {
					window.LMSChat.setMessageReadStatus(message.id, 'database_read', true);
				}
			}
		}
		// Long Polling経由の場合は一切スクロールしない
		if (!options.fromLongPoll && isCurrentUser) {
			const isOptimistic = message.is_optimistic || message.id.toString().includes('_');
			if (isOptimistic) {
			} else {
				scrollThreadToBottom(true, $newMessage[0]);
			}
		}
		if (window.LMSUnifiedSync) {
			setTimeout(() => {
				if (typeof window.LMSUnifiedSync.startThreadMessageObserver === 'function') {
					window.LMSUnifiedSync.startThreadMessageObserver();
				}
				if (typeof window.LMSUnifiedSync.observeThreadMessages === 'function') {
					window.LMSUnifiedSync.observeThreadMessages();
				}
			}, 200);
		}

		// スレッド情報更新を削除（thread-info-sync.jsのイベントハンドラーに一本化）
		// メインチャットのDOM更新によるスクロール問題を回避するため、
		// スレッド情報更新はthread-info-sync.jsのthread:reply:sentイベント経由で行う

		return true;
	};
	const showNewMessageIndicator = () => {
		return;
	};
	const scrollThreadToBottom = (
		smooth = false,
		newMessage = null,
		disableAutoScrollAfter = false
	) => {
		const $threadMessages = $('.thread-messages');
		if (!$threadMessages.length) return;
		if (
			!disableAutoScrollAfter &&
			(state.preventAutoScroll || window.LMSChat.threads.preventAutoScroll)
		) {
			return;
		}
		if (!window.threadScrollDebounce) {
			window.threadScrollDebounce = {
				timer: null,
				pendingScroll: false,
			};
		}
		if (window.threadScrollDebounce.pendingScroll) {
			return;
		}
		window.threadScrollDebounce.pendingScroll = true;
		if (window.threadScrollDebounce.timer) {
			clearTimeout(window.threadScrollDebounce.timer);
		}
		window.threadScrollDebounce.timer = setTimeout(() => {
			if (smooth) {
				$threadMessages.addClass('smooth-scroll').removeClass('auto-scroll');
			} else {
				$threadMessages.addClass('auto-scroll').removeClass('smooth-scroll');
			}
			if ($threadMessages[0]) {
				const scrollHeight = $threadMessages[0].scrollHeight;
				$threadMessages.scrollTop(scrollHeight + 100);
			}
			if (newMessage) {
				const $newMessage = $(newMessage);
				if ($newMessage.hasClass('new-reply')) {
					const messageId = $newMessage.data('message-id');
					if (messageId && window.LMSChat.messages && window.LMSChat.messages.markMessageAsRead) {
						window.LMSChat.messages.markMessageAsRead(messageId, true);
					}
				}
			}
			if (disableAutoScrollAfter) {
				setTimeout(() => {
					state.preventAutoScroll = true;
					if (window.LMSChat.threads) {
						window.LMSChat.threads.preventAutoScroll = true;
					}
				}, 100);
			}
			window.threadScrollDebounce.pendingScroll = false;
		}, 50);
		if (smooth) {
			setTimeout(() => {
				$threadMessages.addClass('auto-scroll').removeClass('smooth-scroll');
			}, 800);
		}
	};
	const setupThreadUserActivity = () => {
		const $threadInput = $('#thread-input, #thread-message-input');
		if (!$threadInput.length) return;
		let typingTimer;
		const doneTypingInterval = 1000;
		$threadInput.on('input', function () {
			clearTimeout(typingTimer);
			typingTimer = setTimeout(() => {}, doneTypingInterval);
		});
		$threadInput.on('focus', function () {});
		$threadInput.on('blur', function () {});
	};
	const markThreadAsRead = (parentMessageId) => {
		if (!parentMessageId || !window.lmsChat.currentUserId) return;
		const messageIds = $('.thread-message')
			.map(function () {
				return $(this).data('message-id');
			})
			.get();
		if (messageIds.length === 0) return;
		const nonce = window.lmsChat && window.lmsChat.nonce ? window.lmsChat.nonce : '';
		const ajaxUrl = window.lmsChat && window.lmsChat.ajaxUrl ? window.lmsChat.ajaxUrl : '';
		if (!nonce || !ajaxUrl) {
			return;
		}
		$.ajax({
			url: ajaxUrl,
			type: 'POST',
			data: {
				action: 'lms_mark_thread_messages_as_read',
				parent_message_id: parentMessageId,
				message_ids: messageIds,
				nonce: nonce,
			},
			success: function (response) {
				if (response.success) {
					const $messageElement = $(`.chat-message[data-message-id="${parentMessageId}"]`);
					const hasThreadInfo = $messageElement.find('.thread-info').length > 0;
					if (
						!hasThreadInfo &&
						window.LMSChat.messages &&
						typeof window.LMSChat.messages.updateThreadInfo === 'function'
					) {
						window.LMSChat.messages.updateThreadInfo(parentMessageId);
					} else if (hasThreadInfo) {
					}
					if (window.LMSChat.state && window.LMSChat.state.threadUnreadCache) {
						const cache = window.LMSChat.state.threadUnreadCache;
						if (cache.has(parentMessageId.toString())) {
							const cacheData = cache.get(parentMessageId.toString());
							cacheData.unread = 0;
							cacheData.timestamp = Date.now();
							cache.set(parentMessageId.toString(), cacheData);
						}
					}
					if ($messageElement.length) {
						const $unreadBadge = $messageElement.find('.thread-unread-badge');
						if ($unreadBadge.length) {
							$unreadBadge.fadeOut(300, function () {
								$(this).remove();
							});
						}
					}
				}
			},
		});
	};
	const setupThreadScroll = () => {
		$('.thread-messages').off('scroll');
		$('.thread-messages').on(
			'scroll',
			utils.debounce(function () {
				const $visibleMessages = $('.thread-message:visible');
				const containerHeight = $(this).height();
				$visibleMessages.each(function () {
					const $message = $(this);
					const $newMark = $message.find('.new-mark');
					if ($newMark.length > 0) {
						const messageTop = $message.position().top;
						if (messageTop >= 0 && messageTop < containerHeight) {
							const messageId = $message.data('message-id');
							if (messageId) {
								const isFirstView = !$message.hasClass('viewed-once');
								if (isFirstView) {
									$message.addClass('viewed-once');
									window.LMSChat.messages.markMessageAsRead(messageId, true, true);
								} else {
									window.LMSChat.messages.markMessageAsRead(messageId, true, false);
								}
							}
						}
					}
				});
			}, 200)
		);
	};
	const sendThreadReply = async (parentMessageId, message, fileIds = []) => {
		if (!sendThreadReply.lastSendInfo) {
			sendThreadReply.lastSendInfo = {
				messageId: null,
				message: null,
				timestamp: 0,
			};
		}
		const now = Date.now();
		if (
			sendThreadReply.lastSendInfo.messageId === parentMessageId &&
			sendThreadReply.lastSendInfo.message === message &&
			now - sendThreadReply.lastSendInfo.timestamp < 1000
		) {
			return { success: false, reason: 'duplicate_prevention' };
		}
		if (state.isSendingThread || !message.trim()) {
			return { success: false, reason: 'in_progress_or_empty' };
		}
		sendThreadReply.lastSendInfo.messageId = parentMessageId;
		sendThreadReply.lastSendInfo.message = message;
		sendThreadReply.lastSendInfo.timestamp = now;
		state.isSendingThread = true;
		$('#thread-send-button').prop('disabled', true);
		try {
			const response = await $.ajax({
				url: lmsChat.ajaxUrl,
				type: 'POST',
				data: {
					action: 'lms_send_thread_message',
					parent_message_id: parentMessageId,
					message: message,
					file_ids: fileIds,
					nonce: lmsChat.nonce,
					timestamp: now,
				},
				dataType: 'json',
				timeout: 3000,
			});
			state.isSendingThread = false;
			$('#thread-send-button').prop('disabled', false);
			if (response.success) {
				$('#thread-input').val('').css('height', 'auto');
				$('.thread-file-preview').empty();
				if (
					window.LMSChat.uploads &&
					typeof window.LMSChat.uploads.getThreadPendingFiles === 'function'
				) {
					const pendingFiles = window.LMSChat.uploads.getThreadPendingFiles();
					if (pendingFiles) {
						for (const [key, value] of pendingFiles.entries()) {
							if (!key.endsWith('_url') && value && value.status === 'uploaded') {
								pendingFiles.delete(key);
								pendingFiles.delete(`${key}_url`);
							}
						}
					}
				}
				const messageData = response.data;
				appendThreadMessage(messageData);
				const $newMessage = $(`.thread-message[data-message-id="${messageData.id}"]`);
				const $threadMessages = $('.thread-messages');
				if ($threadMessages.length && $threadMessages[0]) {
					$threadMessages.scrollTop($threadMessages[0].scrollHeight);
				}
				updateThreadTimestamps();
				if (messageData.id) {
					state.lastThreadMessageId = parseInt(messageData.id, 10);

					// 仮メッセージIDを削除して実際のIDを追加
					if (!window.LMSChat.state.recentSentMessageIds) {
						window.LMSChat.state.recentSentMessageIds = new Set();
					}
					if (!window.LMSChat.state.recentSentMessageTimes) {
						window.LMSChat.state.recentSentMessageTimes = new Map();
					}

					// 仮IDがある場合は削除（optimisticMessageIdをクロージャーからアクセスできない場合のため、全ての一時IDをクリア）
					const tempIdsToRemove = [];
					window.LMSChat.state.recentSentMessageIds.forEach(id => {
						if (String(id).includes('_')) { // 一時IDの形式: timestamp_randomstring
							tempIdsToRemove.push(id);
						}
					});
					tempIdsToRemove.forEach(id => {
						window.LMSChat.state.recentSentMessageIds.delete(id);
						window.LMSChat.state.recentSentMessageTimes.delete(id);
					});

					// 実際のIDを追加
					window.LMSChat.state.recentSentMessageIds.add(String(messageData.id));
					window.LMSChat.state.recentSentMessageTimes.set(String(messageData.id), Date.now());

					// 10秒後にクリーンアップ
					setTimeout(() => {
						if (window.LMSChat.state.recentSentMessageIds) {
							window.LMSChat.state.recentSentMessageIds.delete(String(messageData.id));
						}
						if (window.LMSChat.state.recentSentMessageTimes) {
							window.LMSChat.state.recentSentMessageTimes.delete(String(messageData.id));
						}
					}, 10000);
				}
				// refreshThreadInfo呼び出しを削除（thread:reply:sentイベント経由で更新）
				$(document).trigger('message_sent', [messageData]);
				$(document).trigger('thread:reply:sent', [parentMessageId, messageData]);
				if (
					window.LMSThreadSync &&
					typeof window.LMSThreadSync.displayOwnThreadMessage === 'function'
				) {
				}
				$(document).trigger('lms_longpoll_thread_message_posted', [
					{
						messageId: messageData.id,
						parentId: parentMessageId,
						threadId: parentMessageId,
						payload: messageData,
					},
				]);
				if (
					window.LMSChat.messages &&
					typeof window.LMSChat.messages.queueThreadUpdate === 'function'
				) {
					window.LMSChat.messages.queueThreadUpdate(parentMessageId);
				}
				setTimeout(() => {
					if (
						window.LMSChat.messages &&
						typeof window.LMSChat.messages.updateThreadInfo === 'function'
					) {
						window.LMSChat.messages.updateThreadInfo(parentMessageId);
					}
				}, 500);
				return { success: true, data: response.data };
			} else {
				utils.showError(response.data || 'メッセージの送信に失敗しました');
				return { success: false, reason: 'server_error', error: response.data };
			}
		} catch (error) {
			state.isSendingThread = false;
			$('#thread-send-button').prop('disabled', false);
			utils.showError('メッセージの送信中にエラーが発生しました');
			return { success: false, reason: 'network_error', error };
		}
	};
	let threadUpdateQueue = new Set();
	let threadUpdateTimeout = null;
	const queueThreadUpdate = (messageId) => {
		threadUpdateQueue.add(messageId);
		if (!threadUpdateTimeout) {
			threadUpdateTimeout = setTimeout(() => {
				processThreadUpdateQueue();
			}, 1000);
		}
	};
	const processThreadUpdateQueue = async () => {
		if (threadUpdateQueue.size === 0) {
			threadUpdateTimeout = null;
			return;
		}
		const messageIds = Array.from(threadUpdateQueue);
		threadUpdateQueue.clear();
		threadUpdateTimeout = null;
		try {
			for (const messageId of messageIds) {
				await updateThreadInfo(messageId);
			}
		} catch (error) {}
	};
	const closeThread = () => {
		if (window.threadLoadRetryTimer) {
			clearTimeout(window.threadLoadRetryTimer);
			window.threadLoadRetryTimer = null;
		}
		const parentMessageId = state.currentThread;
		const $threadPanel = $('.thread-panel');

		// 状態を即座にリセット（重複開くのを防ぐため）
		state.currentThread = null;
		state.lastThreadMessageId = 0;
		state.unreadThreadMessages = [];
		if (window.LMSChat?.state) {
			window.LMSChat.state.currentThread = null;
			window.LMSChat.state.lastThreadMessageId = 0;
			window.LMSChat.state.unreadThreadMessages = [];
		}

		// アニメーション開始
		$threadPanel.removeClass('open').addClass('closing');
		$threadPanel.removeAttr('data-current-thread-id');

		// クラスクリアのタイミングを短縮（300ms → 150ms）
		setTimeout(() => {
			$threadPanel.removeClass('closing');
			$('body').removeClass('thread-open');
			$(document).trigger('thread:closed', [parentMessageId]);
			if (parentMessageId) {
				try {
					const threadMessageCount = $('.thread-messages .thread-message').length;
					if (!window.LMSChat.state.threadInfoCache) {
						window.LMSChat.state.threadInfoCache = new Map();
					}
					const existingInfo = window.LMSChat.state.threadInfoCache.get(parentMessageId) || {};
					const threadInfo = {
						total: Math.max(threadMessageCount, existingInfo.total || 0),
						unread: existingInfo.unread || 0,
						avatars: existingInfo.avatars || [],
						latest_reply: existingInfo.latest_reply || '',
						timestamp: Date.now(),
					};
					if (threadInfo.total > 0) {
						window.LMSChat.state.threadInfoCache.set(parentMessageId, threadInfo);
					} else {
						window.LMSChat.state.threadInfoCache.delete(parentMessageId);
						if (window.ThreadInfoUpdateManager && window.ThreadInfoUpdateManager.globalLock) {
							window.ThreadInfoUpdateManager.globalLock.add(`force_delete_${parentMessageId}`);
						}
					}
					if (
						window.LMSChat.messages &&
						typeof window.LMSChat.messages.updateMessageThreadInfo === 'function'
					) {
						const $message = $(`.chat-message[data-message-id="${parentMessageId}"]`);
						if ($message.length) {
							window.LMSChat.messages.updateMessageThreadInfo($message, threadInfo);
							setTimeout(() => {
								const $messageAgain = $(`.chat-message[data-message-id="${parentMessageId}"]`);
								if ($messageAgain.length && $messageAgain.find('.thread-info').length === 0) {
									window.LMSChat.messages.updateMessageThreadInfo($messageAgain, threadInfo);
								}
							}, 500);
							setTimeout(() => {
								const $messageFinal = $(`.chat-message[data-message-id="${parentMessageId}"]`);
								if ($messageFinal.length && $messageFinal.find('.thread-info').length === 0) {
									window.LMSChat.messages.updateMessageThreadInfo($messageFinal, threadInfo);
								}
							}, 2000);
						}
					}
					if (
						window.LMSChat.messages &&
						typeof window.LMSChat.messages.updateThreadInfo === 'function'
					) {
						window.LMSChat.messages.updateThreadInfo(parentMessageId);
					}
				} catch (error) {}
			}
		}, 150); // アニメーション時間を短縮
	};
	const markThreadMessageAsRead = async (messageId) => {
		try {
			if (!messageId) return false;
			const $message = $(`.thread-message[data-message-id="${messageId}"]`);
			if ($message.length === 0) {
				return false;
			}
			const readStatus = window.LMSChat.getMessageReadStatus
				? window.LMSChat.getMessageReadStatus(messageId, true)
				: null;
			const response = await $.ajax({
				url: window.lmsChat.ajaxUrl,
				type: 'POST',
				data: {
					action: 'lms_mark_message_as_read',
					nonce: window.lmsChat.nonce,
					message_id: messageId,
					is_thread: 1,
				},
			});
			if (response.success) {
				if (state.unreadThreadMessages) {
					const index = state.unreadThreadMessages.indexOf(String(messageId || ''));
					if (index !== -1) {
						state.unreadThreadMessages.splice(index, 1);
					}
				}
				const currentStatus = window.LMSChat.getMessageReadStatus(messageId, true);
				let newStatus = currentStatus;
				if (currentStatus === null) {
					newStatus = 'first_view';
					if (window.LMSChat.setMessageReadStatus) {
						window.LMSChat.setMessageReadStatus(messageId, 'first_view', true);
					}
				} else if (currentStatus === 'first_view' && $message.hasClass('viewed-once')) {
					const viewCount =
						window.LMSChat.messages && window.LMSChat.messages.messageViewTracker
							? window.LMSChat.messages.messageViewTracker.getCount(messageId, true) || 0
							: 0;
					if (viewCount > 1) {
						newStatus = 'fully_read';
						if (window.LMSChat.setMessageReadStatus) {
							window.LMSChat.setMessageReadStatus(messageId, 'fully_read', true);
						}
					} else {
					}
				}
				$message.attr('data-read-status', newStatus);
				$message.addClass('viewed-once');
				if (newStatus === 'fully_read') {
					$message.addClass('read-completely');
					$message.find('.new-mark').fadeOut(300, function () {
						$(this).remove();
					});
				} else if (newStatus === 'first_view') {
					if ($message.find('.new-mark').length === 0) {
						$message.find('.user-name').after('<span class="new-mark">New</span>');
					}
				}
				return true;
			} else {
				return false;
			}
		} catch (error) {
			return false;
		}
	};
	const markVisibleThreadMessagesAsRead = () => {
		if (!$('.thread-panel').hasClass('open')) return;
		const $threadMessages = $('.thread-messages .thread-message:visible');
		const $container = $('.thread-messages');
		const containerHeight = $container.height();
		const scrollTop = $container.scrollTop();
		$threadMessages.each(function () {
			const $message = $(this);
			const $newMark = $message.find('.new-mark');
			if ($newMark.length > 0) {
				const messageTop = $message.position().top;
				if (messageTop >= 0 && messageTop < containerHeight) {
					const messageId = $message.data('message-id');
					if (messageId) {
						markThreadMessageAsRead(messageId);
					}
				}
			}
		});
	};
	const setupThreadReadTracking = () => {
		$('.thread-messages')
			.off('scroll.read')
			.on(
				'scroll.read',
				utils.debounce(function () {
					markVisibleThreadMessagesAsRead();
				}, 300)
			);
		$(document).on('thread:opened', function () {});
	};
	const setupThreadEventListeners = () => {
		$(document).off('click', '.close-thread');
		$(document).off('click', '.close-thread-btn');
		$('.close-thread').off('click');
		$('.close-thread-btn').off('click');

		$(document).on('click', '.close-thread, .close-thread-btn', function (e) {
			e.preventDefault();
			e.stopPropagation();
			e.stopImmediatePropagation();
			// 確実にスレッドを閉じる
			window.forceCloseThread();
			return false;
		});

		$(document).on('click', function (e) {
			if ($(e.target).hasClass('close-thread-btn') || $(e.target).hasClass('close-thread')) {
				e.preventDefault();
				e.stopPropagation();

				try {
					if (typeof window.closeThread === 'function') {
						window.closeThread();
					} else if (
						window.LMSChat?.threads &&
						typeof window.LMSChat.threads.closeThread === 'function'
					) {
						window.LMSChat.threads.closeThread();
					} else {
						window.forceCloseThread();
					}
				} catch (error) {
					// 最終フォールバック
					window.forceCloseThread();
				}
				return false;
			}
		});

		// スレッドボタンクリックのイベントハンドラ（重複防止のため既存を削除）
		$(document).off('click.threadOpen', '.thread-button, .thread-info');

		// 処理中フラグ
		let isProcessingClick = false;

		$(document).on('click.threadOpen', '.thread-button, .thread-info', function (e) {
			e.preventDefault();
			e.stopPropagation();

			const $this = $(this);
			const messageId = $this.data('message-id') || $this.closest('.chat-message').data('message-id');

			if (!messageId || isProcessingClick) {
				return;
			}

			// 処理中フラグを設定
			isProcessingClick = true;

			// バッジを一時的に非表示（必要な場合）
			if (!$('#click-thread-badge-hide').length) {
				$('<style>')
					.prop('type', 'text/css')
					.prop('id', 'click-thread-badge-hide')
					.html('.unread-badge { display: none !important; }')
					.appendTo('head');
				setTimeout(() => {
					$('#click-thread-badge-hide').remove();
				}, 100);
			}

			// スレッドを即座に開く（デバウンスなし）
			openThread(messageId).finally(() => {
				// 処理完了後にフラグをリセット
				isProcessingClick = false;
			});
		});
		$(document).on('click', function (e) {
			const $threadPanel = $('.thread-panel');
			if (
				!$threadPanel.hasClass('open') &&
				!$threadPanel.hasClass('show') &&
				!$threadPanel.is(':visible')
			) {
				return;
			}
			const emojiPickerActive = $('.emoji-picker.active, .emoji-picker:visible').length > 0;
			if (emojiPickerActive) {
				return;
			}
			const modalActive = $('.modal:visible, .dialog:visible, .tooltip:visible').length > 0;
			if (modalActive) {
				return;
			}
			const deleteDialogActive =
				$(
					'.thread-delete-confirm-dialog:visible, .thread-delete-confirm-overlay:visible, .parent-delete-confirm-dialog:visible, .parent-delete-confirm-overlay:visible, .delete-confirm-dialog:visible'
				).length > 0;
			if (deleteDialogActive) {
				return;
			}
			const warningDialogActive =
				$(
					'.not-last-message-warning:visible, .parent-message-delete-warning:visible, .thread-delete-warning:visible'
				).length > 0;
			if (warningDialogActive) {
				return;
			}
			const excludeSelectors = [
				'.thread-panel',
				'.thread-button',
				'.thread-info',
				'.thread-reply-count',
				'.emoji-picker',
				'.add-reaction',
				'.reaction-picker',
				'.message-actions',
				'.context-menu',
				'.dropdown-menu',
				'.upload-progress',
				'.file-preview',
				'.thread-delete-confirm-dialog',
				'.thread-delete-confirm-overlay',
				'.parent-delete-confirm-dialog',
				'.parent-delete-confirm-overlay',
				'.delete-confirm-dialog',
				'.not-last-message-warning',
				'.not-last-message-warning-overlay',
				'.parent-message-delete-warning',
				'.parent-message-delete-warning-overlay',
				'.thread-delete-warning',
			].join(', ');
			const isOutsideClick = !$(e.target).closest(excludeSelectors).length;
			if (isOutsideClick) {
				window.forceCloseThread();
			}
		});
		$(document).on('keydown', function (e) {
			if (e.keyCode === 27 || e.key === 'Escape') {
				const $threadPanel = $('.thread-panel');
				if (
					$threadPanel.hasClass('open') ||
					$threadPanel.hasClass('show') ||
					$threadPanel.is(':visible')
				) {
					window.forceCloseThread();
					e.preventDefault();
					e.stopPropagation();
				}
			}
		});
		$(document).on('thread:opened', function (e, messageId) {
			setTimeout(function () {
				$('.parent-message-header .message-actions').addClass('visible');
			}, 200);
		});
		setupThreadReactionEvents();
		setupThreadReadTracking();
	};
	const addThreadMessageToDOM = (messageData, animate = true) => {
		if (!messageData || !messageData.id) {
			return false;
		}
		const currentThreadId = state.currentThread;
		const messageThreadId = messageData.parent_message_id || messageData.thread_id;
		if (currentThreadId && messageThreadId && currentThreadId !== messageThreadId) {
			return false;
		}
		const existingMessage = $(`.thread-message[data-message-id="${messageData.id}"]`);
		if (existingMessage.length > 0) {
			return false;
		}
		const messageHtml = createThreadMessageHtml(messageData);
		const threadMessagesContainer = $('.thread-messages');
		if (threadMessagesContainer.length > 0) {
			threadMessagesContainer.append(messageHtml);
			const newMessage = threadMessagesContainer.find(
				`.thread-message[data-message-id="${messageData.id}"]`
			);
			if (animate) {
				newMessage.fadeIn(300);
			} else {
				newMessage.show();
			}
			setTimeout(() => {
				updateThreadTimestamps();
			}, 100);
		}
		if (messageData.user_id && messageData.user_id !== window.lmsChat.currentUserId) {
			const isCurrentUser =
				parseInt(messageData.user_id) === parseInt(window.lmsChat.currentUserId);
			if (!isCurrentUser) {
				if (!state.unreadThreadMessages) {
					state.unreadThreadMessages = [];
				}
				if (!state.unreadThreadMessages.includes(messageData.id)) {
					state.unreadThreadMessages.push(messageData.id);
				}
			}
		}
		
		// 親メッセージのスレッド情報を更新（メッセージ数とアイコン）
		const parentMessageId = messageThreadId || currentThreadId;
		if (parentMessageId) {
			setTimeout(() => {
				refreshThreadInfo(parentMessageId);
			}, 300);
		}
		
		return true;
	};

	/**
	 * スレッドメッセージ削除処理（他ユーザーからの同期用）
	 */
	const removeThreadMessageFromDOM = (messageId, animate = true) => {
		if (!messageId) {
			return false;
		}

		const $message = $(`.thread-message[data-message-id="${messageId}"]`);
		if ($message.length === 0) {
			return false;
		}

		// 親メッセージIDを取得
		const parentMessageId = $message.data('parent-message-id') || state.currentThread;

		// 削除アニメーション
		if (animate) {
			$message.addClass('being-deleted').fadeOut(300, function () {
				$(this).remove();
				checkThreadEmpty();
				updateThreadInfo();
				
				// 親メッセージのスレッド情報を更新（メッセージ数とアイコン）
				if (parentMessageId) {
					refreshThreadInfo(parentMessageId);
				}
			});
		} else {
			$message.remove();
			checkThreadEmpty();
			updateThreadInfo();
			
			// 親メッセージのスレッド情報を更新（メッセージ数とアイコン）
			if (parentMessageId) {
				refreshThreadInfo(parentMessageId);
			}
		}

		// 未読メッセージリストからも削除
		if (state.unreadThreadMessages) {
			const index = state.unreadThreadMessages.indexOf(messageId);
			if (index > -1) {
				state.unreadThreadMessages.splice(index, 1);
			}
		}

		return true;
	};

	/**
	 * スレッドが空かどうかチェックして適切なメッセージを表示
	 */
	const checkThreadEmpty = () => {
		const $threadMessages = $('.thread-messages');
		const $visibleMessages = $threadMessages.find('.thread-message:visible').not('.being-deleted');

		if ($visibleMessages.length === 0) {
			// 既存の "no-messages" を削除してから新しく追加
			$threadMessages.find('.no-messages').remove();
			$threadMessages.append('<div class="no-messages">このスレッドにはまだ返信がありません</div>');
		} else {
			// メッセージがある場合は "no-messages" を削除
			$threadMessages.find('.no-messages').remove();
		}
	};

	window.LMSChat.threads = {
		openThread,
		closeThread,
		sendThreadReply,
		updateThreadInfo,
		appendThreadMessage,
		scrollThreadToBottom,
		markThreadAsRead,
		addThreadMessageToDOM,
		removeThreadMessageFromDOM,
		handleDeletedMessage: function (eventData) {
			// 🔧 修正: 統合ロングポーリング対応のメッセージ削除ハンドラー
			const messageId = eventData?.id || eventData?.message_id;
			const parentMessageId = eventData?.parent_message_id || eventData?.parentMessageId || state.currentThread;
			
			if (messageId) {
				removeThreadMessageFromDOM(messageId, true);
				
				// 親メッセージのスレッド情報を更新（メッセージ数とアイコン）
				if (parentMessageId) {
					setTimeout(() => {
						refreshThreadInfo(parentMessageId);
					}, 300);
				}
			}
		},
		// 統合Long Polling対応メソッド
		handleNewMessage: function (eventData) {
			// イベントデータからメッセージを取得
			const messageData = eventData?.payload || eventData;
			const parentMessageId = messageData?.parent_message_id || messageData?.parentMessageId || state.currentThread;
			
			if (messageData && messageData.id) {
				// 重複チェック
				const existingMessage = $(`.thread-message[data-message-id="${messageData.id}"]`);
				if (existingMessage.length === 0) {
					// Long Polling経由での受信なのでスクロールしない
					appendThreadMessage(messageData, { fromLongPoll: true });
					
					// 親メッセージのスレッド情報を更新（メッセージ数とアイコン）
					if (parentMessageId) {
						setTimeout(() => {
							refreshThreadInfo(parentMessageId);
						}, 300);
					}
				}
			}
		},
	};
	window.appendThreadMessage = appendThreadMessage;
	window.createThreadMessageHtml = createThreadMessageHtml;
	const updateThreadTimestamps = () => {
		const complementTimeWithToday = (timeStr) => {
			if (!timeStr) return null;
			const timeOnlyPattern = /^(\d{1,2}):(\d{2})$/;
			if (timeOnlyPattern.test(timeStr)) {
				try {
					const today = new Date();
					const match = timeStr.match(timeOnlyPattern);
					if (!match || match.length < 3) return null;
					const hours = parseInt(match[1], 10);
					const minutes = parseInt(match[2], 10);
					if (
						isNaN(hours) ||
						isNaN(minutes) ||
						hours < 0 ||
						hours > 23 ||
						minutes < 0 ||
						minutes > 59
					) {
						return null;
					}
					today.setHours(hours, minutes, 0, 0);
					return today.toISOString();
				} catch (e) {
					return null;
				}
			}
			return null;
		};
		try {
			$('.thread-message .message-time, .thread-parent-user .message-time').each(function () {
				try {
					const currentText = $(this).text().trim();
					let rawTimestamp = $(this).attr('data-timestamp') || '';
					if (!rawTimestamp && currentText) {
						const complementedTimestamp = complementTimeWithToday(currentText);
						if (complementedTimestamp) {
							rawTimestamp = complementedTimestamp;
							$(this).attr('data-timestamp', rawTimestamp);
						}
					}
					if (rawTimestamp) {
						try {
							const formatted = formatMessageTime(rawTimestamp);
							if (formatted) {
								$(this).text(formatted);
							}
						} catch (formatError) {}
					}
				} catch (elementError) {}
			});
		} catch (error) {}
	};
	$(document).on('visibilitychange', function () {
		if (!document.hidden && $('.thread-panel.open').length > 0) {
			$('.thread-message:visible').each(function () {
				const $msg = $(this);
				const msgId = $msg.data('message-id');
				if (
					msgId &&
					window.LMSChat &&
					window.LMSChat.messages &&
					window.LMSChat.messages.messageViewTracker
				) {
					const isFullyRead = window.LMSChat.messages.messageViewTracker.isFullyRead(msgId, true);
					const viewCount = window.LMSChat.messages.messageViewTracker.getCount(msgId, true);
					if (!isFullyRead && viewCount >= 1) {
						window.LMSChat.messages.messageViewTracker.markAsFullyRead(msgId, true);
						$msg.addClass('read-completely');
					}
				}
			});
		}
	});
	const setupThreadReactionEvents = () => {
		// 重複登録を防ぐため、既存のイベントハンドラーを削除
		$(document).off('click', '.thread-message .reaction-item');
		$(document).off('click', '.parent-message-reactions .reaction-item');

		// スレッド専用リアクションハンドラーを優先登録（遅延実行で確実に優先）
		setTimeout(() => {
			$(document).on('click', '.thread-message .reaction-item', function (e) {
				e.preventDefault();
				e.stopPropagation();
				const emoji = $(this).data('emoji');
				const $message = $(this).closest('.thread-message');
				const messageId = $message.data('message-id');
				if (!messageId || !emoji) {
					return;
				}
				if ($(this).hasClass('processing')) {
					return;
				}
				$(this).addClass('processing');
				$('.reaction-tooltip').remove();
				const processReaction = async () => {
					try {
						if (window.LMSChat.reactions && window.LMSChat.reactions.toggleThreadReaction) {
							await window.LMSChat.reactions.toggleThreadReaction(messageId, emoji);
						} else if (window.toggleThreadReaction) {
							await window.toggleThreadReaction(messageId, emoji);
						}
					} catch (error) {
					} finally {
						$(this).removeClass('processing');
					}
				};
				processReaction();
			});

			// 親メッセージリアクションハンドラーも同時に登録
			$(document).on('click', '.parent-message-reactions .reaction-item', function (e) {
				e.preventDefault();
				e.stopPropagation();
				const emoji = $(this).data('emoji');
				const messageId = $('.parent-message').data('message-id');
				const isUserReacted = $(this).hasClass('user-reacted');
				if (!messageId || !emoji) {
					return;
				}
				if (
					window.LMSChat &&
					window.LMSChat.preventDuplicateReaction &&
					window.LMSChat.preventDuplicateReaction(messageId, emoji, 'PARENT-CLICK-HANDLER')
				) {
					return;
				}
				$('.reaction-tooltip').remove();
				if (window.LMSChat.reactions && window.LMSChat.reactions.toggleReaction) {
					window.LMSChat.reactions.toggleReaction(messageId, emoji, false);
				} else if (window.toggleReaction) {
					window.toggleReaction(messageId, emoji);
				}
			});
		}, 50); // 50ms遅延で専用ハンドラーを確実に優先登録
	};
	(function () {
		const BUTTON_SELECTORS =
			'button.send-button, .thread-send-button, #thread-send-button, #thread-message-submit';
		const INPUT_SELECTORS = '#thread-input, #thread-message-input, .thread-input, textarea';
		function updateSendButtonState() {
			const inputs = document.querySelectorAll(INPUT_SELECTORS);
			if (!inputs.length) return;
			let hasText = false;
			inputs.forEach((input) => {
				if (input.value && input.value.trim().length > 0) {
					hasText = true;
				}
			});
			const buttons = document.querySelectorAll(BUTTON_SELECTORS);
			buttons.forEach((button) => {
				if (hasText) {
					button.disabled = false;
					button.removeAttribute('disabled');
					button.classList.add('active');
					button.style.backgroundColor = '#0066ff';
					button.style.color = 'white';
					button.style.opacity = '1';
					button.style.cursor = 'pointer';
				} else {
					button.disabled = true;
					button.setAttribute('disabled', 'disabled');
					button.classList.remove('active');
					button.style.backgroundColor = '#cccccc';
					button.style.color = '#666666';
					button.style.opacity = '0.5';
					button.style.cursor = 'default';
				}
			});
		}
		function setupInputListeners() {
			const inputs = document.querySelectorAll(INPUT_SELECTORS);
			inputs.forEach((input) => {
				input.removeEventListener('input', updateSendButtonState);
				input.removeEventListener('keyup', updateSendButtonState);
				input.removeEventListener('focus', updateSendButtonState);
				input.addEventListener('input', updateSendButtonState);
				input.addEventListener('keyup', updateSendButtonState);
				input.addEventListener('focus', updateSendButtonState);
				if (document.activeElement === input) {
					updateSendButtonState();
				}
			});
		}
		function directButtonFix() {
			const sendButtons = document.querySelectorAll('button.send-button');
			sendButtons.forEach((button) => {
				const form = button.closest('form');
				if (!form) return;
				const input = form.querySelector('textarea, input[type="text"]');
				if (!input) return;
				const hasText = input.value && input.value.trim().length > 0;
				if (hasText) {
					button.disabled = false;
					button.removeAttribute('disabled');
					button.style.backgroundColor = '#0066ff';
					button.style.color = 'white';
					button.style.opacity = '1';
					button.style.cursor = 'pointer';
				}
			});
		}
		function applyButtonFix() {
			setupInputListeners();
			updateSendButtonState();
			directButtonFix();
		}
		function startFixInterval() {
			applyButtonFix();
			setTimeout(applyButtonFix, 1000);
			setInterval(applyButtonFix, 15000);
		}
		window.fixSendButton = applyButtonFix;
	})();
	const setupThreadReactionObserver = () => {
		if (!window.MutationObserver) {
			return;
		}
		const observeThreadMessages = () => {
			const $threadMessages = $('.thread-messages');
			if (!$threadMessages.length) return;
			const checkScrollPosition = () => {
				const isNearBottom =
					$threadMessages.scrollTop() + $threadMessages.innerHeight() >=
					$threadMessages[0].scrollHeight - 150;
				if (isNearBottom) {
					scrollThreadToBottom(true);
				}
			};
			const observer = new MutationObserver((mutations) => {
				// 同期受信時のスクロールを防ぐため、MutationObserverによる自動スクロールは無効化
				// const hasReactionChanges = mutations.some((mutation) => {
				// 	if (mutation.type === 'childList') {
				// 		return (
				// 			Array.from(mutation.addedNodes).some(
				// 				(node) =>
				// 					node.nodeType === 1 &&
				// 					($(node).hasClass('message-reactions') ||
				// 						$(node).find('.message-reactions').length)
				// 			) ||
				// 			Array.from(mutation.removedNodes).some(
				// 				(node) =>
				// 					node.nodeType === 1 &&
				// 					($(node).hasClass('message-reactions') ||
				// 						$(node).find('.message-reactions').length)
				// 			)
				// 		);
				// 	}
				// 	return false;
				// });
				// if (hasReactionChanges) {
				// 	setTimeout(checkScrollPosition, 100);
				// 	setTimeout(checkScrollPosition, 500);
				// }
			});
			observer.observe($threadMessages[0], {
				childList: true,
				subtree: true,
				attributes: true,
				attributeFilter: ['class'],
			});
			$(document).on('thread:closed', function () {
				observer.disconnect();
			});
		};
		$(document).on('thread:opened', function () {
			setTimeout(observeThreadMessages, 500);
		});
		if ($('.thread-panel').hasClass('open')) {
			observeThreadMessages();
		}
	};
	const checkParentMessageScroll = () => {
		const $parentMessageBody = $('.parent-message-body');
		if ($parentMessageBody.length) {
			const contentHeight = $parentMessageBody.prop('scrollHeight');
			const visibleHeight = $parentMessageBody.height();
			const scrollTop = $parentMessageBody.scrollTop();
			const threshold = 20;
			if (contentHeight > visibleHeight + threshold) {
				if (!$parentMessageBody.hasClass('scrollable')) {
					$parentMessageBody.addClass('scrollable');
					setupParentMessageScrollDetection($parentMessageBody);
				}
			} else {
				if ($parentMessageBody.hasClass('scrollable') || $parentMessageBody.hasClass('scrolling')) {
					$parentMessageBody.removeClass('scrollable scrolling');
					$parentMessageBody.off('scroll.scrollDetection touchmove.scrollDetection');
					$parentMessageBody.removeData('scroll-detection-setup');
				}
			}
		}
	};
	const setupParentMessageScrollDetection = ($element) => {
		if ($element.data('scroll-detection-setup')) {
			return;
		}
		$element.data('scroll-detection-setup', true);
		let scrollTimer = null;
		$element.on('scroll.scrollDetection touchmove.scrollDetection', function () {
			$element.addClass('scrolling');
			if (scrollTimer) {
				clearTimeout(scrollTimer);
				scrollTimer = null;
			}
			scrollTimer = setTimeout(() => {
				$element.removeClass('scrolling');
				scrollTimer = null;
			}, 800);
		});
		const initialScrollTop = $element.scrollTop();
		if (initialScrollTop > 0) {
			$element.addClass('scrolling');
			setTimeout(() => {
				$element.removeClass('scrolling');
			}, 1000);
		}
	};
	const setupParentMessageObserver = () => {
		if (!window.MutationObserver) {
			return;
		}
		const observer = new MutationObserver((mutations) => {
			setTimeout(checkParentMessageScroll, 100);
		});
		$(document).on('thread:opened', function () {
			setTimeout(() => {
				checkParentMessageScroll();
			}, 300);
			setTimeout(() => {
				checkParentMessageScroll();
				const $parentMessage = $('.parent-message');
				if ($parentMessage.length) {
					observer.observe($parentMessage[0], {
						childList: true,
						subtree: true,
						characterData: true,
						attributes: true,
					});
					const $parentMessageBody = $('.parent-message-body');
					if ($parentMessageBody.length && $parentMessageBody.hasClass('scrollable')) {
						setupParentMessageScrollDetection($parentMessageBody);
					}
				}
			}, 800);
			setTimeout(() => {
				checkParentMessageScroll();
			}, 1500);
			setTimeout(() => {
				const $parentMessageBody = $('.parent-message-body');
				if ($parentMessageBody.length) {
					const contentHeight = $parentMessageBody.prop('scrollHeight');
					const visibleHeight = $parentMessageBody.height();
					const threshold = 20;
					if (contentHeight > visibleHeight + threshold) {
						if (!$parentMessageBody.hasClass('scrollable')) {
							$parentMessageBody.addClass('scrollable');
							setupParentMessageScrollDetection($parentMessageBody);
						}
					} else {
						if (
							$parentMessageBody.hasClass('scrollable') ||
							$parentMessageBody.hasClass('scrolling')
						) {
							$parentMessageBody.removeClass('scrollable scrolling');
							$parentMessageBody.off('scroll.scrollDetection touchmove.scrollDetection');
							$parentMessageBody.removeData('scroll-detection-setup');
						}
					}
				}
			}, 3000);
		});
		$(document).on('thread:closed', function () {
			observer.disconnect();
			$('.parent-message-body').off('scroll.scrollDetection touchmove.scrollDetection');
			$('.parent-message-body').removeData('scroll-detection-setup');
		});
		$(document).on(
			'reaction:added reaction:removed thread_reaction:added thread_reaction:removed',
			function () {
				setTimeout(() => {
					checkParentMessageScroll();
					const $parentMessageBody = $('.parent-message-body');
					if ($parentMessageBody.length && $parentMessageBody.hasClass('scrollable')) {
						setupParentMessageScrollDetection($parentMessageBody);
					}
				}, 300);
			}
		);
		$(window).on('resize', function () {
			clearTimeout(window.resizeTimer);
			window.resizeTimer = setTimeout(() => {
				checkParentMessageScroll();
			}, 250);
		});
	};
	const applyParentMessageStyles = () => {
		if ($('#parent-message-scroll-style').length === 0) {
			const css = `
				.parent-message-body {
					max-height: 200px;
					overflow-y: auto;
					position: relative;
					padding-right: 12px;
					transition: all 0.3s ease;
				}
				.parent-message-body.scrollable {
					border-left: 3px solid #f0f0f0;
					padding-left: 10px;
				}
				.parent-message-body::before,
				.parent-message-body::after {
					content: '';
					position: absolute;
					opacity: 0;
					transition: opacity 0.3s ease;
					pointer-events: none;
				}
				.parent-message-body.scrollable::before {
					bottom: 15px;
					right: 15px;
					width: 30px;
					height: 30px;
					background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='rgba(0,0,0,0.5)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M7 13l5 5 5-5'/%3E%3Cpath d='M7 6l5 5 5-5'/%3E%3C/svg%3E");
					background-size: contain;
					background-position: center;
					background-repeat: no-repeat;
					background-color: rgba(255, 255, 255, 0.9);
					border-radius: 50%;
					box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
					z-index: 1005;
					opacity: 0.8;
					transform: translateY(0);
					animation: scroll-hint 2s ease-in-out infinite;
				}
				.parent-message-body.scrollable::after {
					bottom: 0;
					left: 0;
					right: 0;
					height: 60px;
					background: linear-gradient(
						to bottom,
						rgba(248, 249, 250, 0) 0%,
						rgba(248, 249, 250, 0.8) 50%,
						rgba(248, 249, 250, 1) 100%
					);
					z-index: 1004;
					opacity: 1;
				}
				.parent-message-body.scrolling::before {
					opacity: 0;
					transform: translateY(10px);
					animation: none;
				}
				.parent-message-body.scrolling::after {
					opacity: 0;
				}
				@keyframes scroll-hint {
					0%, 100% {
						transform: translateY(0);
					}
					50% {
						transform: translateY(5px);
					}
				}
				.parent-message-body::-webkit-scrollbar {
					width: 6px;
				}
				.parent-message-body::-webkit-scrollbar-track {
					background: rgba(0, 0, 0, 0.03);
					border-radius: 3px;
				}
				.parent-message-body::-webkit-scrollbar-thumb {
					background: rgba(0, 0, 0, 0.15);
					border-radius: 3px;
				}
				.parent-message-body::-webkit-scrollbar-thumb:hover {
					background: rgba(0, 0, 0, 0.25);
				}
			`;
			$('<style id="parent-message-scroll-style"></style>').append(css).appendTo('head');
		}
	};
	const threadErrorCss = `
		.connection-error {
			background-color: rgba(255, 0, 0, 0.1);
			border-left: 4px solid #f44336;
			padding: 10px 15px;
			margin: 10px 0;
			border-radius: 4px;
			text-align: center;
		}
		.connection-error p {
			margin: 5px 0;
			color: #f44336;
		}
		.connection-error button {
			background-color: #f44336;
			color: white;
			border: none;
			padding: 5px 15px;
			margin-top: 5px;
			border-radius: 4px;
			cursor: pointer;
		}
		.connection-error button:hover {
			background-color: #d32f2f;
		}
		.loading-indicator {
			text-align: center;
			padding: 20px 0;
			margin: 10px 0;
		}
	`;
	$(document).ready(function () {
		setTimeout(() => {
			$('.unread-badge').each(function () {
				const $badge = $(this);
				const text = $badge.text().trim();
				if (text === '6' || text === '3' || text === '8' || text === '4') {
					$badge.text('').hide();
				}
			});
		}, 100);
		if ($('#thread-error-styles').length === 0) {
			$('<style id="thread-error-styles">').text(threadErrorCss).appendTo('head');
		}
		if (!window.LMSChat || !window.LMSChat.utils || !window.LMSChat.utils.validateChatConfig) {
			return;
		}
		if (!window.LMSChat.utils.validateChatConfig()) return;
		setupThreadEventListeners();
		setupThreadInputHandlers();
		enhanceThreadInputControls();
		fixThreadInputControls();
		// setupThreadDeleteHandlers(); // Disabled - ThreadDeleteManager handles deletion
		setupThreadReactionObserver();
		setupParentMessageObserver();
		applyParentMessageStyles();
		$(document).on('thread:opened', function () {
			setTimeout(checkParentMessageScroll, 300);
			setTimeout(checkParentMessageScroll, 1000);
		});
		$(window).on('resize', utils.debounce(checkParentMessageScroll, 200));
		$(document).on(
			'reaction:added reaction:removed thread_reaction:added thread_reaction:removed',
			function () {
				setTimeout(checkParentMessageScroll, 300);
			}
		);
		// 同期受信時のスクロールを防ぐため、リアクションイベントによる自動スクロールは無効化
	// $(document).on(
	// 	'reaction:added reaction:removed thread_reaction:added thread_reaction:removed',
	// 	function () {
	// 		if (state.currentThread && $('.thread-panel').hasClass('open')) {
	// 			setTimeout(() => {
	// 				const $threadMessages = $('.thread-messages');
	// 				const isNearBottom =
	// 					$threadMessages.length &&
	// 					$threadMessages.scrollTop() + $threadMessages.innerHeight() >=
	// 						$threadMessages[0].scrollHeight - 150;
	// 				if (isNearBottom) {
	// 					scrollThreadToBottom(true);
	// 				}
	// 			}, 300);
	// 			setTimeout(() => {
	// 				const $threadMessages = $('.thread-messages');
	// 				const isNearBottom =
	// 					$threadMessages.length &&
	// 					$threadMessages.scrollTop() + $threadMessages.innerHeight() >=
	// 						$threadMessages[0].scrollHeight - 150;
	// 				if (isNearBottom) {
	// 					scrollThreadToBottom(true);
	// 				}
	// 			}, 800);
	// 		}
	// 	}
	// );
		window.openThread = openThread;
		window.sendThreadMessage = sendThreadMessage;
		window.refreshThreadInfo = refreshThreadInfo;
		window.LMSChat = window.LMSChat || {};
		window.LMSChat.state = state;
	});
	const setupThreadInputHandlers = () => {
		$('#thread-input, #thread-message-input').off('input keydown');
		$('#thread-panel .send-button, #thread-send-button, .thread-send-button').off('click');
		$('#thread-input, #thread-message-input').on('input', function () {
			const hasText = $(this).val().trim().length > 0;
			const $button = $('#thread-panel .send-button, #thread-send-button, .thread-send-button');
			if (hasText) {
				$button.prop('disabled', false).addClass('active');
			} else {
				$button.prop('disabled', true).removeClass('active');
			}
		});
		$('#thread-input, #thread-message-input').on('keydown', function (e) {
			if (e.key === 'Enter') {
				if (e.ctrlKey || e.metaKey) {
					e.preventDefault();
					const $input = $(this);
					const message = $input.val().trim();
					if (message) {
						const parentMessageId = state.currentThread;
						if (parentMessageId) {
							const fileIds = [];
							if (state.pendingFiles && state.pendingFiles.size > 0) {
								state.pendingFiles.forEach((_, id) => fileIds.push(id));
							}
							sendThreadMessage(parentMessageId, message, fileIds);
							$input.val('').trigger('input');
							if (state.pendingFiles) {
								state.pendingFiles.clear();
							}
							$('.thread-file-preview').empty();
						}
					}
				}
			}
			setTimeout(() => updateButtonState({ target: e.target }), 0);
		});
		$('#thread-panel .send-button, #thread-send-button, .thread-send-button').on(
			'click',
			function (e) {
				e.preventDefault();
				if ($(this).prop('disabled') || !$(this).hasClass('active')) {
					return;
				}
				const $input = $('#thread-input, #thread-message-input').first();
				const message = $input.val().trim();
				if (!message) return;
				const parentMessageId = state.currentThread;
				if (!parentMessageId) return;
				const fileIds = [];
				if (state.pendingFiles && state.pendingFiles.size > 0) {
					state.pendingFiles.forEach((_, id) => fileIds.push(id));
				}
				sendThreadMessage(parentMessageId, message, fileIds);
			}
		);
		setTimeout(() => {
			$('#thread-input, #thread-message-input').each(function () {
				const hasText = $(this).val().trim().length > 0;
				const $button = $('.send-button');
				if (hasText) {
					$button.prop('disabled', false).addClass('active');
				} else {
					$button.prop('disabled', true).removeClass('active');
				}
			});
			$('#thread-input, #thread-message-input').first().trigger('input');
		}, 10);
	};
	$(document).on('thread:opened', function (e, threadId) {
		setupThreadInputHandlers();
		setTimeout(() => {
			$('#thread-input, #thread-message-input').first().focus();
		}, 200);
		if (
			window.LMSChat &&
			window.LMSChat.reactions &&
			typeof window.LMSChat.reactions.loadReactionsForThread === 'function'
		) {
			window.LMSChat.reactions.loadReactionsForThread(threadId);
		}
	});
	const enhanceThreadInputControls = () => {
		const updateButtonStyle = () => {
			$('#thread-panel .send-button, #thread-send-button, .thread-send-button').each(function () {
				const $input = $('#thread-input, #thread-message-input').first();
				const hasText = $input.length && $input.val().trim().length > 0;
				if (hasText) {
					$(this)
						.prop('disabled', false)
						.addClass('active')
						.attr(
							'style',
							'opacity: 1 !important; background-color: #0066ff !important; color: white !important; cursor: pointer !important;'
						);
				} else {
					$(this)
						.prop('disabled', true)
						.removeClass('active')
						.attr(
							'style',
							'opacity: 0.5 !important; background-color: #cccccc !important; color: #666666 !important; cursor: default !important;'
						);
				}
			});
		};
		const $inputs = $('#thread-input, #thread-message-input');
		$inputs.off('input.enhanced').on('input.enhanced', function () {
			updateButtonStyle();
		});
		$inputs.off('keydown.enhanced').on('keydown.enhanced', function (e) {
			if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
				e.preventDefault();
				e.stopPropagation();
				const $button = $('.send-button').first();
				const hasText = $(this).val().trim().length > 0;
				if (hasText) {
					const parentMessageId = window.LMSChat.state.currentThread;
					if (parentMessageId) {
						const message = $(this).val().trim();
						const fileIds = [];
						if (window.LMSChat.state.pendingFiles && window.LMSChat.state.pendingFiles.size > 0) {
							window.LMSChat.state.pendingFiles.forEach((_, id) => fileIds.push(id));
						}
						window.sendThreadMessage(parentMessageId, message, fileIds);
						$(this).val('').trigger('input');
					}
				}
			}
		});
		updateButtonStyle();
		const intervalId = setInterval(updateButtonStyle, 500);
		setTimeout(() => {
			clearInterval(intervalId);
		}, 5000);
	};
	$(document).on('thread:opened', function () {
		setTimeout(enhanceThreadInputControls, 300);
	});
	$(document).ready(function () {
		setTimeout(enhanceThreadInputControls, 500);
	});
	const fixThreadInputControls = () => {
		const forcedStyles = `
	.send-button.active {
		background-color: #0066ff !important;
		color: white !important;
		opacity: 1 !important;
		cursor: pointer !important;
		pointer-events: auto !important;
	}
	.send-button:not(.active) {
		background-color: #cccccc !important;
		color: #666666 !important;
		opacity: 0.5 !important;
		cursor: default !important;
		pointer-events: none !important;
	}
`;
		const styleElement = document.createElement('style');
		styleElement.type = 'text/css';
		styleElement.appendChild(document.createTextNode(forcedStyles));
		document.head.appendChild(styleElement);
		function emergencyFix() {
			function updateButtonState() {
				const inputField = document.querySelector('#thread-input, #thread-message-input');
				if (!inputField) return;
				const buttons = document.querySelectorAll(
					'.thread-send-button, #thread-send-button, #thread-message-submit'
				);
				if (!buttons.length) return;
				const hasText = inputField.value.trim().length > 0;
				buttons.forEach((button) => {
					if (hasText) {
						button.disabled = false;
						button.classList.add('active');
						button.style.cssText =
							'background-color: #0066ff !important; color: white !important; opacity: 1 !important; cursor: pointer !important;';
					} else {
						button.disabled = true;
						button.classList.remove('active');
						button.style.cssText =
							'background-color: #cccccc !important; color: #666666 !important; opacity: 0.5 !important; cursor: default !important;';
					}
				});
			}
			function fixEnterKeyBehavior() {
				const inputField = document.querySelector('#thread-input, #thread-message-input');
				if (!inputField) return;
				inputField.removeEventListener('keydown', handleKeydown);
				inputField.addEventListener('keydown', handleKeydown);
				function handleKeydown(e) {
					if (e.key === 'Enter') {
						if (e.ctrlKey || e.metaKey) {
							e.preventDefault();
							const activeButton = document.querySelector(
								'.thread-send-button.active, #thread-send-button.active, #thread-message-submit.active'
							);
							if (activeButton) {
								activeButton.click();
							}
						}
					}
					updateButtonState();
				}
			}
			function watchInput() {
				const inputField = document.querySelector('#thread-input, #thread-message-input');
				if (!inputField) return;
				inputField.addEventListener('input', updateButtonState);
				inputField.addEventListener('focus', updateButtonState);
				updateButtonState();
			}
			fixEnterKeyBehavior();
			watchInput();
			updateButtonState();
		}
		if (document.readyState === 'complete' || document.readyState === 'interactive') {
			setTimeout(emergencyFix, 100);
		} else {
			document.addEventListener('DOMContentLoaded', () => setTimeout(emergencyFix, 100));
		}
		if (typeof jQuery !== 'undefined') {
			jQuery(document).ready(() => setTimeout(emergencyFix, 200));
			jQuery(document).on('thread:opened', () => {
				setTimeout(emergencyFix, 300);
				setTimeout(emergencyFix, 1000);
			});
		}
		setInterval(emergencyFix, 10000);
	};
	$(document).ready(function () {
		setTimeout(fixThreadInputControls, 500);
		$(document).on('thread:opened', function () {
			setTimeout(fixThreadInputControls, 300);
		});
		setInterval(function () {
			const $input = $('#thread-input, #thread-message-input').first();
			if ($input.length) {
				$input.trigger('input');
			}
		}, 10000);
	});
	/*
	// この即時実行関数は使用されない（無効化）
	(function () {
		const BUTTON_SELECTORS =
			'.thread-send-button, #thread-send-button, #thread-message-submit, .send-button';
		const INPUT_SELECTORS = '#thread-input, #thread-message-input, .thread-input';
		function fixSendButton() {
			const inputs = document.querySelectorAll(INPUT_SELECTORS);
			const buttons = document.querySelectorAll(BUTTON_SELECTORS);
			if (!inputs.length || !buttons.length) {
				return;
			}
			inputs.forEach((input) => {
				input.removeEventListener('input', updateButtonState);
				input.removeEventListener('keydown', handleKeyDown);
				input.addEventListener('input', updateButtonState);
				input.addEventListener('keydown', handleKeyDown, true);
				updateButtonState({ target: input });
			});
		}
		function applyFixes() {
			fixSendButton();
			const checkInterval = setInterval(fixSendButton, 5000);
			setTimeout(() => {
				clearInterval(checkInterval);
			}, 30000);
		}
		if (document.readyState === 'complete' || document.readyState === 'interactive') {
			setTimeout(applyFixes, 100);
		} else {
			document.addEventListener('DOMContentLoaded', () => setTimeout(applyFixes, 100));
		}
		if (typeof jQuery !== 'undefined') {
			jQuery(document).ready(() => setTimeout(applyFixes, 200));
			jQuery(document).on('thread:opened', () => {
				setTimeout(applyFixes, 300);
				setTimeout(applyFixes, 1000);
			});
		}
		window.fixThreadControls = applyFixes;
	})();
	*/
	function setupThreadDeleteHandlers() {
		// この関数は使用されない（無効化）
		return;
		/*
		// 既存のイベントハンドラを完全に削除
		$(document).off('click', '.thread-message .delete-thread-message');
		$(document).off('click', '.delete-thread-message');
		$(document).off('click', '.action-button.delete-thread-message');
		$(document).off('click', '.delete-parent-message');

		// レガシーハンドラは無効化済み
		return;
		*/
	}
	
	// グローバルデバッグ関数
	window.debugThreadDelete = {
		// デバッグ: ボタンの存在を確認
		checkButtons: function () {
			const buttons = $('.action-button.delete-thread-message');

			buttons.each(function (index) {
				const $btn = $(this);
				const $msg = $btn.closest('.thread-message');
				const msgId = $msg.data('message-id');

			});
			return buttons.length;
		},

		// デバッグ: 手動でボタンクリックをシミュレート
		simulateClick: function (messageId) {
			const selector = messageId
				? `.thread-message[data-message-id="${messageId}"] .action-button.delete-thread-message`
				: '.action-button.delete-thread-message:first';
			const $button = $(selector);
			if ($button.length) {

				$button.trigger('click');
			} else {

			}
		},

		// デバッグ: イベントハンドラの確認
		checkHandlers: function () {
			const events = $._data(document, 'events');
			if (events && events.click) {
				const deleteHandlers = events.click.filter(
					(e) => e.selector && e.selector.includes('delete-thread-message')
				);

				deleteHandlers.forEach((handler, index) => {

				});
			} else {

			}
		},

		// デバッグ: 全体診断
		diagnose: function () {

			this.checkButtons();
			this.checkHandlers();


		},
	};

	// setupThreadDeleteHandlers を完全に無効化（削除ハンドラーの重複を防ぐ）
	// 新しいシンプルな削除ハンドラーを使用
	function updateButtonState(e) {
		const input = e.target || e;
		const value = input.value.trim();
		const hasText = value.length > 0;
		let $button;
		if ($(input).attr('id') === 'thread-input') {
			$button = $('#thread-send-button');
		} else {
			$button = $(input).closest('form').find('button[type="submit"]');
		}
		if ($button.length) {
			$button.prop('disabled', !hasText);
			$button.toggleClass('active', hasText);
			if (hasText) {
				$button.addClass('active');
			} else {
				$button.removeClass('active');
			}
		}
	}
	function handleKeyDown(e) {
		if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
			e.preventDefault();
			const $input = $(e.target);
			const $button = $input.closest('form').find('button[type="submit"]');
			if (!$button.prop('disabled')) {
				$button.trigger('click');
			}
		}
	}
	$(document).on('thread:opened', function () {
		// setupThreadDeleteHandlers(); // Disabled - ThreadDeleteManager handles deletion
	});
	$(document).ready(function () {
		// setupThreadDeleteHandlers(); // Disabled - ThreadDeleteManager handles deletion
	});
	function setupTextareaAutoResize(textarea) {
		if (!textarea) return;
		const minHeight = parseInt(window.getComputedStyle(textarea).height) || 40;
		function adjustHeight() {
			textarea.style.height = 'auto';
			const newHeight = Math.max(textarea.scrollHeight, minHeight);
			textarea.style.height = newHeight + 'px';
		}
		textarea.removeEventListener('input', adjustHeight);
		textarea.addEventListener('input', adjustHeight);
		textarea.removeEventListener('focus', adjustHeight);
		textarea.addEventListener('focus', adjustHeight);
		adjustHeight();
		window.addEventListener('resize', adjustHeight);
		return {
			adjust: adjustHeight,
			destroy: function () {
				textarea.removeEventListener('input', adjustHeight);
				textarea.removeEventListener('focus', adjustHeight);
				window.removeEventListener('resize', adjustHeight);
			},
		};
	}
	$(document).ready(function () {
		const threadInput = document.getElementById('thread-input');
		if (threadInput) {
			setupTextareaAutoResize(threadInput);
		}
		$(document).on('thread:opened', function () {
			setTimeout(function () {
				const newThreadInput = document.getElementById('thread-input');
				if (newThreadInput) {
					setupTextareaAutoResize(newThreadInput);
				}
			}, 300);
		});
	});
	function sendThreadMessage(parentMessageId, message, fileIds = []) {
		if (!sendThreadMessage.lastSendInfo) {
			sendThreadMessage.lastSendInfo = {
				messageId: null,
				message: null,
				timestamp: 0,
				inProgress: false,
			};
		}
		if (!window.threadMessageSendCounter) {
			window.threadMessageSendCounter = 0;
		}
		window.threadMessageSendCounter++;
		if (!window.threadMessageSendLog) {
			window.threadMessageSendLog = [];
		}
		const sendLogEntry = {
			counter: window.threadMessageSendCounter,
			parentMessageId: parentMessageId,
			message: message,
			timestamp: new Date().toISOString(),
			optimisticId: null,
		};
		window.threadMessageSendLog.push(sendLogEntry);
		const now = Date.now();
		if (!window.LMSChat.state.recentlySentMessages) {
			window.LMSChat.state.recentlySentMessages = new Set();
		}
		if (!window.LMSChat.state.sentMessageContents) {
			window.LMSChat.state.sentMessageContents = new Map();
		}
		const messageKey = `${message}_${Math.floor(now / 60000)}`;
		window.LMSChat.state.recentlySentMessages.add(messageKey);
		window.LMSChat.state.sentMessageContents.set(message, now);
		setTimeout(() => {
			window.LMSChat.state.recentlySentMessages.delete(messageKey);
			window.LMSChat.state.sentMessageContents.delete(message);
		}, 5 * 60 * 1000);
		const existingOptimistic = $(
			`.thread-message[data-optimistic="true"], .thread-message.optimistic-message`
		);
		const optimisticMessageId = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
		sendLogEntry.optimisticId = optimisticMessageId;

		// 仮メッセージIDをrecentSentMessageIdsに即座に追加（同期システムでの重複防止）
		if (!window.LMSChat.state.recentSentMessageIds) {
			window.LMSChat.state.recentSentMessageIds = new Set();
		}
		if (!window.LMSChat.state.recentSentMessageTimes) {
			window.LMSChat.state.recentSentMessageTimes = new Map();
		}
		window.LMSChat.state.recentSentMessageIds.add(String(optimisticMessageId));
		window.LMSChat.state.recentSentMessageTimes.set(String(optimisticMessageId), Date.now());

		const currentUserId = window.lmsChat?.currentUserId ||
			window.LMSChat?.state?.currentUserId ||
			$('#chat-messages').data('current-user-id') || 0;

		const currentUserName =
			window.lmsChat?.currentUserName ||
			window.lmsChat?.userName ||
			window.LMSChat?.state?.currentUserName ||
			$('.user-name.current-user-name').first().text().trim() ||
			$('.current-user .user-name').first().text().trim() ||
			$('#current-user-name').text().trim() ||
			($('#chat-messages').data('current-user-name') || '').trim() ||
			'ユーザー';
		const optimisticMessageData = {
		id: optimisticMessageId,
		parent_message_id: parentMessageId,
		message: message,
		user_id: currentUserId,
		user_name: currentUserName,
		display_name: currentUserName,
		avatar_url:
			window.lmsChat?.currentUserAvatar || '/wp-content/themes/lms/img/default-avatar.png',
		created_at: new Date().toISOString(),
		formatted_time: new Date().toLocaleTimeString('ja-JP', {
			hour: '2-digit',
			minute: '2-digit',
		}),
		is_optimistic: true,
		is_current_user: true,
		file_ids: fileIds,
		attachments: [],
	};
	const result = appendThreadMessage(optimisticMessageData);

	// 楽観的UI更新を削除（thread-info-sync.jsのイベントハンドラーに一本化）
	// メインチャットのDOM更新によるスクロール問題を回避するため、
	// スレッド情報更新はthread-info-sync.jsのthread:reply:sentイベント経由で行う

	const cleanupTimer = setTimeout(() => {
		const $staleOptimistic = $(
			`.thread-message[data-message-id="${optimisticMessageId}"].optimistic-message, .thread-message[data-message-id="${optimisticMessageId}"][data-optimistic="true"]`
		);
		if ($staleOptimistic.length > 0) {
			$staleOptimistic.fadeOut(300, function () {
				$(this).remove();
			});
		}
	}, 30000);
	const $threadMessages = $('.thread-messages');
		if ($threadMessages.length && $threadMessages[0]) {
			$threadMessages.addClass('auto-scroll').removeClass('smooth-scroll');
			$threadMessages.scrollTop($threadMessages[0].scrollHeight);
		}
		$('#thread-input, #thread-message-input').val('').trigger('input');
		const $button = $('#thread-send-button');
		sendThreadMessage.lastSendInfo.inProgress = false;
		sendThreadMessage.lastSendInfo.messageId = parentMessageId;
		sendThreadMessage.lastSendInfo.message = message;
		sendThreadMessage.lastSendInfo.timestamp = now;
		return new Promise((resolve, reject) => {
			$.ajax({
				url: lmsChat.ajaxUrl,
				type: 'POST',
				data: {
					action: 'lms_send_thread_message',
					parent_message_id: parentMessageId,
					message: message,
					file_ids: fileIds,
					nonce: lmsChat.nonce,
				},
				timeout: 45000,
				success: function (response) {
					sendThreadMessage.lastSendInfo.inProgress = false;
					$button.prop('disabled', false);
					if (response.success) {
						sendLogEntry.success = true;
						sendLogEntry.completedAt = new Date().toISOString();
						clearTimeout(cleanupTimer);
						if (response.data && response.data.thread_info) {
							const threadInfo = response.data.thread_info;
							const parentMessageId = threadInfo.parent_message_id;
							if (
								parentMessageId &&
								window.LMSChat.messages &&
								typeof window.LMSChat.messages.updateMessageThreadInfo === 'function'
							) {
								const $parentMessage = $(`.chat-message[data-message-id="${parentMessageId}"]`);
								if ($parentMessage.length) {
									const actualTotal = threadInfo.total || 0;
									const threadData = {
										total: actualTotal,
										unread: 0,
										avatars: threadInfo.avatars || [],
										latest_reply: threadInfo.latest_reply || '',
									};
									if (window.LMSUnifiedSync && window.LMSUnifiedSync.lastThreadCounts) {
										window.LMSUnifiedSync.lastThreadCounts[parentMessageId] = actualTotal;
									}
									if (threadInfo.total >= 1) {
										$parentMessage.addClass('has-thread');
									}
									if (
										window.LMSChat.messages &&
										typeof window.LMSChat.messages.updateMessageThreadInfo === 'function'
									) {
										threadData.timestamp = Date.now();
										threadData.priority = 'high';
										threadData.confirmed = true; // サーバー確定済み
										window.LMSChat.messages.updateMessageThreadInfo($parentMessage, threadData);
									}
									
									// スレッド情報が存在しない場合のフォールバック処理（遅延なし）
									if ($parentMessage.find('.thread-info').length === 0) {
											const threadInfoHtml = `
												<div class="thread-info" data-message-id="${parentMessageId}">
													<div class="thread-info-avatars">
														<img src="${
															window.LMSChat?.utils?.getAssetPath(
																'wp-content/themes/lms/img/default-avatar.png'
															) || '/wp-content/themes/lms/img/default-avatar.png'
														}"
															 alt="ユーザー" class="thread-avatar" data-temporary="true">
													</div>
													<div class="thread-info-text">
														<div class="thread-info-status">
															<span class="thread-reply-count">${threadData.total}件の返信</span>
														</div>
														${
															threadData.latest_reply
																? `<div class="thread-info-latest">最終返信: ${threadData.latest_reply}</div>`
																: ''
														}
													</div>
												</div>
											`;
											const $reactions = $parentMessage.find('.message-reactions');
										if ($reactions.length) {
											$reactions.after(threadInfoHtml);
										} else {
											$parentMessage.append(threadInfoHtml);
										}
									}
								}
							}
						}
						let messageData = null;
						if (response.data && response.data.data) {
							messageData = response.data.data;
						} else if (response.data && response.data.message) {
							messageData = response.data.message;
						} else if (response.data) {
							messageData = response.data;
						} else if (response.message) {
							messageData = response.message;
						}
						const $optimisticMessage = $(
							`.thread-message[data-message-id="${optimisticMessageId}"]`
						);
						if ($optimisticMessage.length > 0 && messageData && messageData.id) {
							const messageKey = `thread_message_${messageData.id}`;
							try {
								localStorage.setItem(
									messageKey,
									JSON.stringify({
										id: messageData.id,
										message: messageData.message,
										user_id: messageData.user_id,
										parent_message_id: messageData.parent_message_id,
										created_at: messageData.created_at,
										display_name: messageData.display_name,
										timestamp: Date.now(),
									})
								);
							} catch (e) {}
							const confirmedHtml = createThreadMessageHtml(messageData);
							$optimisticMessage.replaceWith(confirmedHtml);
							const $newMessage = $(`.thread-message[data-message-id="${messageData.id}"]`);
							$newMessage.addClass('confirmed');
							setTimeout(() => {
								$newMessage.removeClass('confirmed');
							}, 300);

							// 仮IDを削除して実際のIDを追加（重複防止システム用）
							if (window.LMSChat.state.recentSentMessageIds) {
								window.LMSChat.state.recentSentMessageIds.delete(String(optimisticMessageId));
								window.LMSChat.state.recentSentMessageIds.add(String(messageData.id));
								window.LMSChat.state.recentSentMessageTimes.delete(String(optimisticMessageId));
								window.LMSChat.state.recentSentMessageTimes.set(String(messageData.id), Date.now());

								// 10秒後にクリーンアップ
								setTimeout(() => {
									if (window.LMSChat.state.recentSentMessageIds) {
										window.LMSChat.state.recentSentMessageIds.delete(String(messageData.id));
										window.LMSChat.state.recentSentMessageTimes.delete(String(messageData.id));
									}
								}, 10000);
							}

							// スレッド最下部にスクロール
							scrollThreadToBottom();
						} else if (messageData && messageData.id) {
							const $existingConfirmed = $(`.thread-message[data-message-id="${messageData.id}"]`);
							if ($existingConfirmed.length === 0) {
								appendThreadMessage(messageData);

								// 実際のIDを追加（重複防止システム用）
								if (window.LMSChat.state.recentSentMessageIds) {
									// 仮IDがあれば削除
									const tempIdsToRemove = [];
									window.LMSChat.state.recentSentMessageIds.forEach(id => {
										if (String(id).includes('_')) {
											tempIdsToRemove.push(id);
										}
									});
									tempIdsToRemove.forEach(id => {
										window.LMSChat.state.recentSentMessageIds.delete(id);
										window.LMSChat.state.recentSentMessageTimes.delete(id);
									});

									window.LMSChat.state.recentSentMessageIds.add(String(messageData.id));
									window.LMSChat.state.recentSentMessageTimes.set(String(messageData.id), Date.now());

									// 10秒後にクリーンアップ
									setTimeout(() => {
										if (window.LMSChat.state.recentSentMessageIds) {
											window.LMSChat.state.recentSentMessageIds.delete(String(messageData.id));
											window.LMSChat.state.recentSentMessageTimes.delete(String(messageData.id));
										}
									}, 10000);
								}

								// 新規メッセージ追加後にスクロール
								scrollThreadToBottom();
							} else {
							}
						} else {
						}
						$('.thread-file-preview').empty();
						if (
							window.LMSChat &&
							window.LMSChat.uploads &&
							typeof window.LMSChat.uploads.clearThreadUploads === 'function'
						) {
							window.LMSChat.uploads.clearThreadUploads();
						}
						$(document).trigger('thread:reply:sent', [parentMessageId, response.data]);
						$(document).trigger('lms_chat_thread_message_sent', [response.data]);
						
						// スレッドメッセージ送信成功時にキャッシュをクリア（次回開いた時に最新データを取得）
						if (window.LMSChat && window.LMSChat.cache && window.LMSChat.cache.threadMessages) {
							// このスレッドの全ページのキャッシュを削除
							const keysToDelete = [];
							window.LMSChat.cache.threadMessages.forEach((value, key) => {
								if (key.startsWith(`${parentMessageId}_`)) {
									keysToDelete.push(key);
								}
							});
							keysToDelete.forEach(key => {
								window.LMSChat.cache.threadMessages.delete(key);
							});
						}
						const $threadMessages = $('.thread-messages');
						$threadMessages.find('.no-messages').remove();
						updateThreadTimestamps();
						if (
							window.LMSChat.messages &&
							typeof window.LMSChat.messages.queueThreadUpdate === 'function'
						) {
							window.LMSChat.messages.queueThreadUpdate(parentMessageId);
						}
						resolve({ success: true, data: response.data });
					} else {
						sendLogEntry.success = false;
						sendLogEntry.error = response.data?.message || 'Unknown server error';
						sendLogEntry.completedAt = new Date().toISOString();
						clearTimeout(cleanupTimer);
						
						// エラー時のロールバック：楽観的に増やした件数を-1に戻す
						const $parentMessage = $(`.chat-message[data-message-id="${parentMessageId}"]`);
						if ($parentMessage.length && window.LMSChat.messages && typeof window.LMSChat.messages.updateMessageThreadInfo === 'function') {
							const $threadReplyCount = $parentMessage.find('.thread-reply-count');
							const currentCount = parseInt($threadReplyCount.text()) || 0;
							const newCount = Math.max(0, currentCount - 1);
							
							const threadData = {
								total: newCount,
								unread: 0,
								avatars: [],
								rollback: true // ロールバックであることを示すフラグ
							};
							
							window.LMSChat.messages.updateMessageThreadInfo($parentMessage, threadData);
							
							if (newCount === 0) {
								$parentMessage.removeClass('has-thread');
							}
						}
						
						const $optimisticMessage = $(
							`.thread-message[data-message-id="${optimisticMessageId}"]`
						);
						if ($optimisticMessage.length > 0) {
							// エラー時でもメッセージを保持し、エラー状態として表示
							$optimisticMessage.addClass('message-error');
							$optimisticMessage
								.find('.message-content')
								.append('<div class="error-indicator">送信に失敗しました</div>');
							// すぐには削除せず、ユーザーが確認できるようにする
							setTimeout(() => {
								if ($optimisticMessage.hasClass('message-error')) {
									$optimisticMessage.fadeOut(300, function () {
										$(this).remove();
									});
								}
							}, 5000); // 5秒後に削除
						}
						$button.prop('disabled', false);
						resolve({ success: false, reason: 'server_error', message: response.data.message });
					}
				},
				error: function (xhr, status, error) {
					sendLogEntry.success = false;
					sendLogEntry.error = `Network error: ${status} - ${error}`;
					sendLogEntry.completedAt = new Date().toISOString();
					sendThreadMessage.lastSendInfo.inProgress = false;
					clearTimeout(cleanupTimer);
					
					// ネットワークエラー時のロールバック：楽観的に増やした件数を-1に戻す
					const $parentMessage = $(`.chat-message[data-message-id="${parentMessageId}"]`);
					if ($parentMessage.length && window.LMSChat.messages && typeof window.LMSChat.messages.updateMessageThreadInfo === 'function') {
						const $threadReplyCount = $parentMessage.find('.thread-reply-count');
						const currentCount = parseInt($threadReplyCount.text()) || 0;
						const newCount = Math.max(0, currentCount - 1);
						
						const threadData = {
							total: newCount,
							unread: 0,
							avatars: [],
							rollback: true // ロールバックであることを示すフラグ
						};
						
						window.LMSChat.messages.updateMessageThreadInfo($parentMessage, threadData);
						
						if (newCount === 0) {
							$parentMessage.removeClass('has-thread');
						}
					}
					
					const $optimisticMessage = $(`.thread-message[data-message-id="${optimisticMessageId}"]`);
					if ($optimisticMessage.length > 0) {
						// ネットワークエラー時もメッセージを保持し、エラー状態として表示
						$optimisticMessage.addClass('message-error');
						$optimisticMessage
							.find('.message-content')
							.append('<div class="error-indicator">ネットワークエラー</div>');
						setTimeout(() => {
							if ($optimisticMessage.hasClass('message-error')) {
								$optimisticMessage.fadeOut(300, function () {
									$(this).remove();
								});
							}
						}, 5000); // 5秒後に削除
					}
					let errorMessage = '通信エラーが発生しました。再度お試しください。';
					if (status === 'timeout') {
						errorMessage = 'リクエストがタイムアウトしました。再度お試しください。';
					} else if (xhr.status === 500) {
						errorMessage = 'サーバーエラーが発生しました。再度お試しください。';
					} else if (xhr.status === 403) {
						errorMessage = '認証エラーです。ページを更新してください。';
					} else if (xhr.status === 0) {
						errorMessage = 'ネットワーク接続を確認してください。';
					}
					$button.prop('disabled', false);
					reject(new Error(`Network error: ${status} - ${error}`));
				},
			});
		});
	}
	$(document).ready(function () {
		if (typeof sendThreadMessage === 'function' && !window.sendThreadMessage) {
			window.sendThreadMessage = sendThreadMessage;
		}
		window.checkThreadSendStatus = function () {
			const total = window.threadMessageSendCounter || 0;
			const log = window.threadMessageSendLog || [];
			const successful = log.filter((entry) => entry.success === true).length;
			const failed = log.filter((entry) => entry.success === false).length;
			const pending = total - successful - failed;
			return {
				total,
				successful,
				failed,
				pending,
				log,
			};
		};
		window.resetThreadSendCounter = function () {
			window.threadMessageSendCounter = 0;
			window.threadMessageSendLog = [];
		};
	});

	// スレッド情報更新の最適化システム
	window.LMSThreadRefreshQueue = window.LMSThreadRefreshQueue || [];
	window.LMSThreadRefreshPending = window.LMSThreadRefreshPending || new Set();
	window.LMSThreadRefreshChannelReady = false;
	window.LMSThreadRefreshRetryCount = window.LMSThreadRefreshRetryCount || 0;

	// チャンネル準備完了監視（10ms間隔、最大5秒）
	$(document).ready(function() {
		function checkChannelReady() {
			const channelId = window.LMSChat?.state?.currentChannel || 0;

			if (channelId > 0 && !window.LMSThreadRefreshChannelReady) {
				window.LMSThreadRefreshChannelReady = true;
				window.LMSThreadRefreshRetryCount = 0;
				processThreadRefreshQueue();
				return;
			}

			if (channelId === 0 && !window.LMSThreadRefreshChannelReady) {
				window.LMSThreadRefreshRetryCount = (window.LMSThreadRefreshRetryCount || 0) + 1;

				if (window.LMSThreadRefreshRetryCount < 500) {
					setTimeout(checkChannelReady, 10);
				} else {
					window.LMSThreadRefreshChannelReady = true;
					processThreadRefreshQueue();
				}
				return;
			}

			if (channelId > 0) {
				window.LMSThreadRefreshRetryCount = 0;
			}
		}

		setTimeout(checkChannelReady, 10);
	});

	function processThreadRefreshQueue() {
		const queue = Array.isArray(window.LMSThreadRefreshQueue) ? window.LMSThreadRefreshQueue.slice() : [];
		window.LMSThreadRefreshQueue = [];

		queue.forEach((item) => {
			if (typeof item === 'object' && item !== null) {
				refreshThreadInfo(item.parentMessageId, item.options || {});
			} else {
				refreshThreadInfo(item);
			}
		});
	}

	function refreshThreadInfo(parentMessageId, options = {}) {
		if (!parentMessageId) {
			return;
		}

		const normalizedOptions = typeof options === 'object' && options !== null ? options : {};
		const retryCount = typeof normalizedOptions.retryCount === 'number' ? normalizedOptions.retryCount : 0;
		const maxRetries = typeof normalizedOptions.maxRetries === 'number' ? normalizedOptions.maxRetries : 2;
		const directDelta = typeof normalizedOptions.delta === 'number' ? normalizedOptions.delta : null;
		const optimisticData =
			normalizedOptions.optimisticData ||
			(directDelta !== null ? { delta: directDelta } : null);

		const pendingKey = `thread_${parentMessageId}`;
		const hasPending = window.LMSThreadRefreshPending.has(pendingKey);
		const allowWhilePending = optimisticData && optimisticData.applyWhilePending === true;

		const $message = $(`.chat-message[data-message-id="${parentMessageId}"]`);
		if ($message.length === 0) {
			return;
		}

		const shouldApplyOptimistic =
			optimisticData &&
			retryCount === 0 &&
			typeof optimisticData.delta === 'number' &&
			!isNaN(optimisticData.delta);

		// 楽観的更新を先に適用するが、サーバーからの最新情報取得は継続
		// （アバター情報更新のため、Ajaxリクエストは必ず実行する）
		if (hasPending && retryCount === 0) {
			if (allowWhilePending && shouldApplyOptimistic) {
				updateMainThreadCounterOptimistic(parentMessageId, optimisticData.delta);
				// 楽観的更新を適用したが、Ajaxリクエストも実行してアバター情報を更新
				// return を削除して処理を継続
			} else {
				// 楽観的更新がない場合は従来通り早期リターン
				return;
			}
		}

		if (shouldApplyOptimistic) {
			updateMainThreadCounterOptimistic(parentMessageId, optimisticData.delta);
		}

		const currentChannelId = window.LMSChat?.state?.currentChannel || 0;

		if (currentChannelId === 0 && !window.LMSThreadRefreshChannelReady) {
			const queue = Array.isArray(window.LMSThreadRefreshQueue) ? window.LMSThreadRefreshQueue : [];
			const alreadyQueued = queue.some((item) => {
				if (typeof item === 'object' && item !== null) {
					return item.parentMessageId === parentMessageId;
				}
				return item === parentMessageId;
			});

			if (!alreadyQueued) {
				queue.push({
					parentMessageId,
					options: {
						maxRetries,
					},
				});
				window.LMSThreadRefreshQueue = queue;
			}
			return;
		}

		// 楽観的更新の場合は並列実行を許可（pendingフラグを設定しない）
		if (!allowWhilePending) {
			window.LMSThreadRefreshPending.add(pendingKey);
		}

		$.ajax({
			url: lmsChat.ajaxUrl,
			type: 'GET',
			timeout: 1000,
			cache: false,
			data: {
				action: 'lms_get_thread_count',
				parent_message_id: parentMessageId,
				nonce: lmsChat.nonce,
			},
			success: function (response) {
				if (!response || !response.success) {
					return;
				}
				const newCurrentChannelId = window.LMSChat?.state?.currentChannel || 0;
				if (newCurrentChannelId !== currentChannelId) {
					return;
				}
				const threadInfo = response.data || {};
				const count = threadInfo.count || threadInfo.total || 0;

				threadInfo.count = count;
				
				// サーバーから返されたアバター情報を処理（オブジェクト形式を保持）
				if (threadInfo.avatars && Array.isArray(threadInfo.avatars) && threadInfo.avatars.length > 0) {
					// 既にオブジェクト形式の場合はそのまま使用
					// 文字列の場合はオブジェクトに変換（後方互換性のため）
					threadInfo.avatars = threadInfo.avatars.map((avatar, index) => {
						if (typeof avatar === 'object' && avatar !== null) {
							// 既にオブジェクト形式
							return avatar;
						} else if (typeof avatar === 'string') {
							// 文字列の場合はオブジェクトに変換
							return {
								avatar_url: avatar,
								display_name: 'ユーザー',
								user_id: 0
							};
						}
						return null;
					}).filter(avatar => avatar !== null);
				}
				
				if (count === 0) {
					if (window.ThreadInfoUpdateManager && window.ThreadInfoUpdateManager.globalLock) {
						window.ThreadInfoUpdateManager.globalLock.add(`force_delete_${parentMessageId}`);
					}
				} else {
					// サーバーから有効なアバター情報が返されていない場合のみ、モーダルから取得
					if (!threadInfo.avatars || threadInfo.avatars.length === 0 || 
						(typeof threadInfo.avatars[0] === 'string' && threadInfo.avatars[0].includes('default-avatar'))) {
						
						const $remainingMessages = $('.thread-messages .thread-message:visible').not('.deleting');
						if ($remainingMessages.length > 0) {
							const $lastMessage = $remainingMessages.last();
							if ($lastMessage.length) {
								const userId = $lastMessage.data('user-id');
								const userName = $lastMessage.find('.user-name').text().trim();
								const userAvatar = $lastMessage.find('.user-avatar img').attr('src') || '';
								
								if (userAvatar && typeof userAvatar === 'string' && !userAvatar.includes('default-avatar')) {
									threadInfo.avatars = [{
										avatar_url: userAvatar,
										display_name: userName,
										user_id: userId
									}];
								} else {
									threadInfo.avatars = [{
										avatar_url: `/wp-content/uploads/avatars/user-avatar${userId}.jpg`,
										display_name: userName,
										user_id: userId
									}];
								}
								
								if (!threadInfo.latest_reply) {
									threadInfo.latest_reply = userName;
								}
							}
						}
					}
				}
				// フリッカー防止: キャッシュの値と比較して変更がない場合はDOM更新をスキップ
				const cachedInfo = window.LMSChat?.state?.threadInfoCache?.get(parentMessageId);
				const hasChanged = !cachedInfo || 
					cachedInfo.count !== count || 
					cachedInfo.total !== count ||
					JSON.stringify(cachedInfo.avatars) !== JSON.stringify(threadInfo.avatars);
				
				if (hasChanged) {
					updateMainThreadCounter(parentMessageId, count, threadInfo);
				} else {
					// キャッシュは更新するが、DOM更新はスキップ
					if (window.LMSChat?.state?.threadInfoCache) {
						window.LMSChat.state.threadInfoCache.set(parentMessageId, {
							...cachedInfo,
							...threadInfo,
							count: count,
							total: count,
							timestamp: Date.now()
						});
					}
				}
				
				const $threadModal = $('.thread-modal');
				if ($threadModal.length) {
					const $threadTitle = $threadModal.find('.thread-title');
					if ($threadTitle.length) {
						$threadTitle.text(`返信スレッド (${threadInfo.count}件)`);
					}
				}
				$(document).trigger('thread:info:updated', [parentMessageId, threadInfo]);
			},
			error: function (xhr, status) {
				if (status === 'timeout' && retryCount < maxRetries) {
					const delay = Math.pow(2, retryCount) * 150;
					setTimeout(() => {
						refreshThreadInfo(parentMessageId, {
							retryCount: retryCount + 1,
							maxRetries,
						});
					}, delay);
				}
			},
			complete: function () {
				window.LMSThreadRefreshPending.delete(pendingKey);
			},
		});
	}
	window.refreshThreadInfo = refreshThreadInfo;

	function updateMainThreadCounterOptimistic(parentMessageId, delta) {
		if (!parentMessageId) {
			return;
		}

		const numericDelta = parseInt(delta, 10);
		if (isNaN(numericDelta) || numericDelta === 0) {
			return;
		}

		const $message = $(`.chat-message[data-message-id="${parentMessageId}"]`);
		if ($message.length === 0) {
			return;
		}

		let currentCount = 0;
		const cache = window.LMSChat?.state?.threadInfoCache;
		if (cache && typeof cache.has === 'function' && cache.has(parentMessageId)) {
			const cachedInfo = cache.get(parentMessageId) || {};
			const cachedTotal = cachedInfo.total !== undefined ? cachedInfo.total : cachedInfo.count;
			currentCount = cachedTotal ? parseInt(cachedTotal, 10) || 0 : 0;
		} else if (typeof $message.data('thread-count') !== 'undefined') {
			currentCount = parseInt($message.data('thread-count'), 10) || 0;
		} else {
			const $countEl = $message
				.find('.thread-info .thread-count, .thread-info .thread-reply-count')
				.first();
			let sourceText = '';
			if ($countEl.length) {
				sourceText = $countEl.text();
			} else {
				const $threadText = $message.find('.thread-button .thread-text').first();
				sourceText = $threadText.length ? $threadText.text() : '';
			}
			if (sourceText) {
				const matches = sourceText.match(/(\d+)/);
				if (matches) {
					currentCount = parseInt(matches[1], 10) || 0;
				}
			}
		}

		const newCount = Math.max(0, currentCount + numericDelta);
		let optimisticInfo = null;

		if (window.LMSChat?.state?.threadInfoCache && window.LMSChat.state.threadInfoCache.has(parentMessageId)) {
			const existingInfo = window.LMSChat.state.threadInfoCache.get(parentMessageId) || {};
			optimisticInfo = {
				...existingInfo,
				total: newCount,
				count: newCount,
				// 既存のアバター情報を保持
				avatars: existingInfo.avatars || [],
				latest_reply: existingInfo.latest_reply || '',
				unread: existingInfo.unread || 0,
				timestamp: Date.now(),
			};
		} else if (newCount > 0) {
			optimisticInfo = {
				total: newCount,
				count: newCount,
				avatars: [], // 空の配列で初期化
				latest_reply: '',
				unread: 0,
				timestamp: Date.now(),
			};
		}

		updateMainThreadCounter(parentMessageId, newCount, optimisticInfo);
	}

	function updateMainThreadCounter(parentMessageId, count, threadInfo = null) {
		if (!parentMessageId) return;


		let safeCount = 0;
		if (count !== undefined && count !== null && !isNaN(count)) {
			safeCount = parseInt(count, 10);
			if (safeCount < 0) {
				safeCount = 0;
			} else if (safeCount > 10000) {
				safeCount = 1000;
			}
		} else {
			if (
				window.LMSChat.state.threadInfoCache &&
				window.LMSChat.state.threadInfoCache.has(parentMessageId)
			) {
				const cachedInfo = window.LMSChat.state.threadInfoCache.get(parentMessageId);
				safeCount = parseInt(cachedInfo.total, 10) || 0;
			} else {
				const $existingButton = $(
					`.chat-message[data-message-id="${parentMessageId}"] .thread-button`
				);
				if ($existingButton.length > 0) {
					const buttonText = $existingButton.text().trim();
					const countMatch = buttonText.match(/(\d+)件の返信/);
					if (countMatch) {
						safeCount = parseInt(countMatch[1], 10);
					}
				}
			}
		}
		count = safeCount;
		const $message = $(`.chat-message[data-message-id="${parentMessageId}"]`);
		if ($message.length === 0) {
			return;
		}
		let $threadButton = $message.find('.thread-button');
		if (count > 0) {
			if ($threadButton.length === 0) {
				const utils =
					window.LMSChat && window.LMSChat.utils
						? window.LMSChat.utils
						: {
								getAssetPath: (path) =>
									path.replace('wp-content/themes/lms/', '/wp-content/themes/lms/'),
						  };
				const threadButtonHtml = `
					<a href="#" class="thread-button" data-message-id="${parentMessageId}">
						<img src="${utils.getAssetPath(
							'wp-content/themes/lms/img/icon-thread.svg'
						)}" alt="" class="thread-icon">
						<span class="thread-text">${count}件の返信</span>
					</a>
				`;
				const $actions = $message.find('.message-actions');
				if ($actions.length > 0) {
					$actions.prepend(threadButtonHtml);
					$threadButton = $message.find('.thread-button');
				}
			} else {
				const $threadText = $threadButton.find('.thread-text');
				const threadText = count > 0 ? `${count}件の返信` : 'スレッドに返信する';
				if ($threadText.length > 0) {
					$threadText.text(threadText);
				} else {
					$threadButton.append(`<span class="thread-text">${threadText}</span>`);
				}
				
				// アイコンが存在しない場合は追加
				let $threadIcon = $threadButton.find('.thread-icon');
				if ($threadIcon.length === 0) {
					const utils =
						window.LMSChat && window.LMSChat.utils
							? window.LMSChat.utils
							: {
									getAssetPath: (path) =>
										path.replace('wp-content/themes/lms/', '/wp-content/themes/lms/'),
							  };
					const iconHtml = `<img src="${utils.getAssetPath(
						'wp-content/themes/lms/img/icon-thread.svg'
					)}" alt="" class="thread-icon">`;
					$threadButton.prepend(iconHtml);
					$threadIcon = $threadButton.find('.thread-icon');
				}
				
			}
			$threadButton.removeClass('hidden').show();
			
			
			// threadInfoCache が存在しない場合は初期化
			if (threadInfo && window.LMSChat && window.LMSChat.state) {
				if (!window.LMSChat.state.threadInfoCache) {
					window.LMSChat.state.threadInfoCache = new Map();
				}
				const existingInfo = window.LMSChat.state.threadInfoCache.get(parentMessageId) || {};
				const updatedInfo = {
					...existingInfo,
					total: count,
					avatars: threadInfo.avatars || existingInfo.avatars || [],
					latest_reply: threadInfo.latest_reply || existingInfo.latest_reply || '',
					unread: threadInfo.unread || existingInfo.unread || 0,
					timestamp: Date.now(),
				};
				window.LMSChat.state.threadInfoCache.set(parentMessageId, updatedInfo);
				if (
					window.LMSChat.messages &&
					typeof window.LMSChat.messages.updateMessageThreadInfo === 'function'
				) {
					window.LMSChat.messages.updateMessageThreadInfo($message, updatedInfo);
				}
		}
	} else {
		if (!window.threadDeletionInProgress) {
			window.threadDeletionInProgress = new Set();
		}
		window.threadDeletionInProgress.add(parentMessageId);
		const $message = $(`.chat-message[data-message-id="${parentMessageId}"]`);
		if ($message.length > 0) {
			const removeThreadElements = () => {
				$message.find('.thread-info, .thread-button, [class*="thread"]').remove();
				$message.removeClass('has-thread');
				$message.removeData('thread-count');
				$message.removeAttr('data-thread-count');
			};
			removeThreadElements();
			setTimeout(() => {
				removeThreadElements();
				setTimeout(() => {
					if (window.threadDeletionInProgress) {
						window.threadDeletionInProgress.delete(parentMessageId);
					}
					if (window.LMSUnifiedSync && window.LMSUnifiedSync.lastThreadCounts) {
						window.LMSUnifiedSync.lastThreadCounts[parentMessageId] = 0;
					}
				}, 100);
			}, 50);
		}
	}

}
	window.updateMainThreadCounter = updateMainThreadCounter;
	function incrementThreadCount(parentMessageId) {
		if (!parentMessageId) return;


		const $message = $(`.chat-message[data-message-id="${parentMessageId}"]`);
		if ($message.length === 0) {
			return;
		}
		let currentCount = 0;
		const $threadInfo = $message.find('.thread-info');
		const $threadButton = $message.find('.thread-button');
		if ($threadInfo.length > 0) {
			const $countEl = $threadInfo.find('.thread-count, .thread-reply-count');
			if ($countEl.length > 0) {
				const countText = $countEl.text();
				const matches = countText.match(/(\d+)/);
				if (matches) {
					currentCount = parseInt(matches[1], 10) || 0;
					if (currentCount < 0) {
						currentCount = 0;
					} else if (currentCount > 9999) {
						currentCount = 999;
					}
				}
			}
		} else if ($threadButton.length > 0) {
			const $countEl = $threadButton.find('.thread-text');
			if ($countEl.length > 0) {
				const countText = $countEl.text();
				const matches = countText.match(/(\d+)/);
				if (matches) {
					currentCount = parseInt(matches[1], 10) || 0;
					if (currentCount < 0) {
						currentCount = 0;
					} else if (currentCount > 9999) {
						currentCount = 999;
					}
				}
			}
		}
		const newCount = currentCount + 1;


		if (!window.LMSChat.state.threadInfoCache) {
			window.LMSChat.state.threadInfoCache = new Map();
		}
		const existingInfo = window.LMSChat.state.threadInfoCache.get(parentMessageId) || {};
		const updatedInfo = {
			total: newCount,
			unread: existingInfo.unread || 0,
			avatars: existingInfo.avatars || [],
			latest_reply: existingInfo.latest_reply || '',
			timestamp: Date.now(),
		};
		if (updatedInfo.total > 0) {
			window.LMSChat.state.threadInfoCache.set(parentMessageId, updatedInfo);
		} else {
			window.LMSChat.state.threadInfoCache.delete(parentMessageId);
			if (window.ThreadInfoUpdateManager && window.ThreadInfoUpdateManager.globalLock) {
				window.ThreadInfoUpdateManager.globalLock.add(`force_delete_${parentMessageId}`);
			}
		}

		// 件数とアイコンを同時に更新
		updateMainThreadCounter(parentMessageId, newCount, updatedInfo);


		if ($threadInfo.length > 0) {
			const $countEl = $threadInfo.find('.thread-count, .thread-reply-count');
			if ($countEl.length > 0) {
				$countEl.text(`${newCount}件の返信`);
			}
		}
	}
	function decrementThreadCount(parentMessageId) {
		if (!parentMessageId) return;


		const $message = $(`.chat-message[data-message-id="${parentMessageId}"]`);
		if ($message.length === 0) {
			return;
		}
		let currentCount = 0;
		const $threadInfo = $message.find('.thread-info');
		const $threadButton = $message.find('.thread-button');
		if ($threadInfo.length > 0) {
			const $countEl = $threadInfo.find('.thread-count, .thread-reply-count');
			if ($countEl.length > 0) {
				const countText = $countEl.text();
				const matches = countText.match(/(\d+)/);
				if (matches) {
					currentCount = parseInt(matches[1], 10) || 0;
				}
			}
		} else if ($threadButton.length > 0) {
			const $countEl = $threadButton.find('.thread-text');
			if ($countEl.length > 0) {
				const countText = $countEl.text();
				const matches = countText.match(/(\d+)/);
				if (matches) {
					currentCount = parseInt(matches[1], 10) || 0;
				}
			}
		}
		const newCount = Math.max(0, currentCount - 1);


		// キャッシュを更新
		if (window.LMSChat.state.threadInfoCache) {
			if (newCount === 0) {
				window.LMSChat.state.threadInfoCache.delete(parentMessageId);
				if (window.ThreadInfoUpdateManager && window.ThreadInfoUpdateManager.globalLock) {
					window.ThreadInfoUpdateManager.globalLock.add(`force_delete_${parentMessageId}`);
				}
			} else {
				const existingInfo = window.LMSChat.state.threadInfoCache.get(parentMessageId) || {};
				const updatedInfo = {
					...existingInfo,
					total: newCount,
					timestamp: Date.now(),
				};
				window.LMSChat.state.threadInfoCache.set(parentMessageId, updatedInfo);
			}
		}

		// 件数とアイコンを同時に更新
		updateMainThreadCounter(parentMessageId, newCount);


		if ($threadInfo.length > 0) {
			if (newCount === 0) {
				$threadInfo.remove();
			} else {
				const $countEl = $threadInfo.find('.thread-count, .thread-reply-count');
				if ($countEl.length > 0) {
					$countEl.text(`${newCount}件の返信`);
				}
			}
		}
	}
	window.incrementThreadCount = incrementThreadCount;
	window.decrementThreadCount = decrementThreadCount;
	function ensureThreadMessageDisplay(messageData, parentMessageId) {
		if (!messageData || !messageData.id) {
			return false;
		}
		try {
			const $existingMessage = $(`.thread-message[data-message-id="${messageData.id}"]`);
			if ($existingMessage.length > 0) {
				return true;
			}
			let messageHtml = '';
			if (typeof createThreadMessageHtml === 'function') {
				const messageViewTracker = window.LMSChat.messages?.messageViewTracker;
				if (messageViewTracker) {
					const viewCount = messageViewTracker.getCount(messageData.id, true);
					if (
						viewCount > 0 &&
						(messageData.is_new === '1' || messageData.is_new === 1 || messageData.is_new === true)
					) {
						messageData.is_new = false;
					}
				}
				messageHtml = createThreadMessageHtml(messageData);
			} else {
				const userName = messageData.user_name || messageData.display_name || 'ユーザー';
				const messageText = messageData.message || '';
				const timestamp = messageData.created_at ? new Date(messageData.created_at) : new Date();
				const formattedTime = timestamp.toLocaleString('ja-JP', {
					month: '2-digit',
					day: '2-digit',
					hour: '2-digit',
					minute: '2-digit',
				});
				messageHtml = `
					<div class="thread-message" data-message-id="${messageData.id}">
						<div class="message-header">
							<div class="message-user">${userName}</div>
							<div class="message-time">${formattedTime}</div>
						</div>
						<div class="message-content">
							<div class="message-text">${messageText}</div>
						</div>
						${
							messageData.reactions && messageData.reactions.length > 0
								? window.LMSChat.reactions.createReactionsHtml(messageData.reactions)
								: ''
						}
						<div class="message-actions">
							<button class="add-reaction" title="リアクションを追加">😀</button>
							<button class="delete-thread-message" title="削除">🗑️</button>
						</div>
					</div>
				`;
			}
			const $threadMessages = $('.thread-messages');
			if ($threadMessages.length === 0) {
				return false;
			}
			$threadMessages.find('.no-messages').remove();
			const fragment = document.createDocumentFragment();
			const tempDiv = document.createElement('div');
			tempDiv.innerHTML = messageHtml;
			while (tempDiv.firstChild) {
				fragment.appendChild(tempDiv.firstChild);
			}
			$threadMessages[0].appendChild(fragment);
			if (window.UnifiedScrollManager) {
				window.UnifiedScrollManager.scrollThreadToBottom(300, true);
			} else {
				$threadMessages.animate({ scrollTop: $threadMessages[0].scrollHeight }, 300);
			}
			if (messageData.attachments && messageData.attachments.length > 0) {
				const $message = $(`.thread-message[data-message-id="${messageData.id}"]`);
				const $content = $message.find('.message-content');
				messageData.attachments.forEach((attachment) => {
					if (!attachment.url || attachment.url === 'undefined' || attachment.url === '') {
						if (attachment.file_path) {
							attachment.url = `${window.lmsChat.uploadBaseUrl || ''}/chat-files/${
								attachment.file_path
							}`;
						} else if (attachment.id) {
							attachment.url = `${window.lmsChat.ajaxUrl}?action=lms_get_file&file_id=${attachment.id}&nonce=${window.lmsChat.nonce}`;
						}
					}
					if (
						(attachment.file_type && attachment.file_type.startsWith('image/')) ||
						(attachment.mime_type && attachment.mime_type.startsWith('image/'))
					) {
						if (
							!attachment.thumbnail_url ||
							attachment.thumbnail_url === 'undefined' ||
							attachment.thumbnail_url === ''
						) {
							if (attachment.thumbnail_path) {
								attachment.thumbnail_url = `${window.lmsChat.uploadBaseUrl || ''}/chat-files/${
									attachment.thumbnail_path
								}`;
							} else {
								attachment.thumbnail_url = attachment.url;
							}
						}
					}
				});
				if (
					window.LMSChat.uploads &&
					typeof window.LMSChat.uploads.createAttachmentHtml === 'function'
				) {
					let attachmentsHtml = '<div class="message-attachments">';
					messageData.attachments.forEach((attachment) => {
						attachmentsHtml += window.LMSChat.uploads.createAttachmentHtml(attachment);
					});
					attachmentsHtml += '</div>';
					$content.append(attachmentsHtml);
				} else {
					let attachmentsHtml = '<div class="message-attachments">';
					messageData.attachments.forEach((attachment) => {
						const fileUrl = attachment.url || '';
						const fileName = attachment.file_name || attachment.name || 'ファイル';
						const fileType = attachment.file_type || attachment.mime_type || '';
						if (
							(fileType && fileType.startsWith('image/')) ||
							['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'].includes(
								fileName.split('.').pop().toLowerCase()
							)
						) {
							const thumbnailUrl =
								attachment.thumbnail_url || attachment.thumbnail || fileUrl || '';
							attachmentsHtml += `
								<div class="attachment-item">
									<div class="attachment-preview">
										<img src="${thumbnailUrl}" alt="${utils.escapeHtml(fileName)}">
										<a href="${fileUrl}" class="attachment-download" download="${utils.escapeHtml(
								fileName
							)}" target="_blank">
											<img src="${utils.getAssetPath('wp-content/themes/lms/img/icon-download.svg')}" alt="ダウンロード">
										</a>
									</div>
									<div class="attachment-info">
										<div class="attachment-name">${utils.escapeHtml(fileName)}</div>
										<div class="attachment-size">${
											attachment.file_size ? utils.formatFileSize(attachment.file_size) : ''
										}</div>
									</div>
								</div>
							`;
						} else {
							attachmentsHtml += `
								<div class="attachment-item">
									<div class="attachment-preview">
										<img src="${utils.getAssetPath(
											'wp-content/themes/lms/img/icon-file.svg'
										)}" class="file-icon" alt="${fileType || '不明なファイル形式'}">
										<a href="${fileUrl}" class="attachment-download" download="${utils.escapeHtml(
								fileName
							)}" target="_blank">
											<img src="${utils.getAssetPath('wp-content/themes/lms/img/icon-download.svg')}" alt="ダウンロード">
										</a>
									</div>
									<div class="attachment-info">
										<div class="attachment-name">${utils.escapeHtml(fileName)}</div>
										<div class="attachment-size">${
											attachment.file_size ? utils.formatFileSize(attachment.file_size) : ''
										}</div>
									</div>
								</div>
							`;
						}
					});
					attachmentsHtml += '</div>';
					$content.append(attachmentsHtml);
				}
			}
			if (window.LMSChat && window.LMSChat.reactions) {
				window.LMSChat.reactions.loadReactionsForThread(parentMessageId);
			}
			return true;
		} catch (err) {
			return false;
		}
	}
	function enhanceThreadSendButton() {
		let isSending = false;
		$(document).off(
			'click',
			'#thread-panel .send-button, #thread-send-button, .thread-send-button'
		);
		$('#thread-panel .send-button, #thread-send-button, .thread-send-button').off('click');
		$(document).on(
			'click',
			'#thread-panel .send-button, #thread-send-button, .thread-send-button',
			function (e) {
				e.preventDefault();
				e.stopPropagation();
				if (isSending) {
					return false;
				}
				if ($(this).prop('disabled')) {
					return false;
				}
				const message = $('#thread-input').val().trim();
				const parentMessageId =
					window.LMSChat && window.LMSChat.state ? window.LMSChat.state.currentThread : null;
				if (!message || !parentMessageId) {
					return false;
				}
				const fileIds = [];
				if (
					window.LMSChat &&
					window.LMSChat.uploads &&
					typeof window.LMSChat.uploads.getThreadPendingFiles === 'function'
				) {
					const pendingFiles = window.LMSChat.uploads.getThreadPendingFiles();
					if (pendingFiles) {
						for (const [key, value] of pendingFiles.entries()) {
							if (!key.endsWith('_url') && value && value.status === 'uploaded') {
								const fileId = parseInt(key, 10);
								if (!isNaN(fileId)) {
									fileIds.push(fileId);
								}
							}
						}
					}
				}
				isSending = true;
				Promise.resolve(sendThreadMessage(parentMessageId, message, fileIds))
					.catch((err) => {})
					.finally(() => {
						setTimeout(() => {
							isSending = false;
						}, 500);
					});
				return false;
			}
		);
		$('#thread-input')
			.off('keydown')
			.on('keydown', function (e) {
				if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
					e.preventDefault();
					e.stopPropagation();
					if (isSending) {
						return false;
					}
					$('#thread-panel .send-button, #thread-send-button, .thread-send-button')
						.first()
						.trigger('click');
					return false;
				}
			});
	}
	$(document).ready(function () {
		enhanceThreadSendButton();
		if (!window.LMSChat) window.LMSChat = {};
		if (!window.LMSChat.sendingStatus)
			window.LMSChat.sendingStatus = {
				isThreadSending: false,
				lastSendTimestamp: 0,
				lastThreadId: null,
				lastMessage: null,
			};
		$(document).on('thread:opened', function () {
			setTimeout(enhanceThreadSendButton, 300);
		});
		window.openThread = openThread;
		if (!window.LMSChat) window.LMSChat = {};
		if (!window.LMSChat.thread) window.LMSChat.thread = {};
		window.LMSChat.thread.openThread = openThread;
		window.LMSChat.thread.sendThreadReply = sendThreadReply;
		$(document).on('submit', 'form', function (e) {
			const $threadInput = $('#thread-input');
			const $threadSendButton = $('.send-button');
			if (
				$threadInput.length > 0 &&
				$threadSendButton.length > 0 &&
				$(this).find('#thread-input, .send-button').length > 0
			) {
				e.preventDefault();
				e.stopPropagation();
				return false;
			}
		});
	});
	const setupThreadMessageObserver = () => {
		if (window.threadMessageObserver) return;
		const observerOptions = {
			root: document.querySelector('.thread-messages'),
			rootMargin: '0px',
			threshold: 0.5,
		};
		window.threadMessageObserver = new IntersectionObserver((entries) => {
			entries.forEach((entry) => {
				if (entry.isIntersecting) {
					const $message = $(entry.target);
					const messageId = $message.data('message-id');
					const isCurrentUser = $message.hasClass('current-user');
					if (!isCurrentUser && messageId) {
						const currentStatus = window.LMSChat.getMessageReadStatus
							? window.LMSChat.getMessageReadStatus(messageId, true)
							: null;
						if (currentStatus === null) {
							if (window.LMSChat.setMessageReadStatus) {
								$message.addClass('viewed-once');
								$message.attr('data-read-status', 'first_view');
								if ($message.find('.new-mark').length === 0) {
									$message.find('.user-name').after('<span class="new-mark">New</span>');
								}
								if (window.LMSChat.messages && window.LMSChat.messages.messageViewTracker) {
									window.LMSChat.messages.messageViewTracker.incrementCount(messageId, true);
								}
								window.LMSChat.setMessageReadStatus(messageId, 'first_view', true);
								if (window.LMSChat.scheduleReadTransition) {
									window.LMSChat.scheduleReadTransition(messageId, true);
								}
							}
						} else if (currentStatus === 'first_view') {
							let viewCount = 1;
							if (window.LMSChat.messages && window.LMSChat.messages.messageViewTracker) {
								window.LMSChat.messages.messageViewTracker.incrementCount(messageId, true);
								viewCount =
									window.LMSChat.messages.messageViewTracker.getCount(messageId, true) || 1;
							}
							if (viewCount > 1) {
								if (window.LMSChat.setMessageReadStatus) {
									$message.find('.new-mark').fadeOut(300, function () {
										$(this).remove();
									});
									$message.addClass('read-completely');
									$message.attr('data-read-status', 'fully_read');
									window.LMSChat.setMessageReadStatus(messageId, 'fully_read', true);
								}
							} else {
								if ($message.find('.new-mark').length === 0) {
									$message.find('.user-name').after('<span class="new-mark">New</span>');
								}
							}
						} else if (currentStatus === 'fully_read') {
							const isNewFromServer = $message.find('.new-mark').length > 0;
							if (isNewFromServer) {
								if (window.LMSChat.setMessageReadStatus) {
									window.LMSChat.setMessageReadStatus(messageId, 'first_view', true);
									$message.removeClass('read-completely').addClass('viewed-once');
									$message.attr('data-read-status', 'first_view');
								}
							}
						}
					}
				}
			});
		}, observerOptions);
		$('.thread-message').each(function () {
			window.threadMessageObserver.observe(this);
		});
		const threadContainer = document.querySelector('.thread-messages');
		if (threadContainer) {
			const mutationCallback = (mutations) => {
				mutations.forEach((mutation) => {
					if (mutation.type === 'childList' && mutation.addedNodes.length) {
						mutation.addedNodes.forEach((node) => {
							if (node.nodeType === 1) {
								const $node = $(node);
								if ($node.hasClass('thread-message')) {
									window.threadMessageObserver.observe(node);
								}
								const $messages = $node.find('.thread-message');
								$messages.each(function () {
									window.threadMessageObserver.observe(this);
								});
							}
						});
					}
				});
			};
			const mutationObserver = new MutationObserver(mutationCallback);
			mutationObserver.observe(threadContainer, {
				childList: true,
				subtree: true,
			});
		}
	};
	$(document).on('message_read_status_changed', function (e, data) {
		if (!data || !data.messageId || !data.isThread) return;
		if (data.isThread) {
			const $threadMessage = $(`.thread-message[data-message-id="${data.messageId}"]`);
			if ($threadMessage.length) {
				if (data.status === 'fully_read') {
					$threadMessage.addClass('read-completely');
					$threadMessage.attr('data-read-status', 'fully_read');
					$threadMessage.find('.new-mark').fadeOut(300, function () {
						$(this).remove();
					});
				} else if (data.status === 'first_view') {
					$threadMessage.addClass('viewed-once');
					$threadMessage.attr('data-read-status', 'first_view');
					if ($threadMessage.find('.new-mark').length === 0) {
						$threadMessage.find('.user-name').after('<span class="new-mark">New</span>');
					}
				}
			}
		}
	});
	const transitionThreadToFullyReadOnSecondView = () => {
		$('.thread-message:visible').each(function () {
			const $msg = $(this);
			const messageId = $msg.data('message-id');
			const isCurrentUser = $msg.hasClass('current-user');
			if (isCurrentUser || !messageId) return;
			const readStatus = window.LMSChat.getMessageReadStatus
				? window.LMSChat.getMessageReadStatus(messageId, true)
				: null;
			if (readStatus === 'first_view') {
				if (window.LMSChat.updateMessageReadStatus) {
					window.LMSChat.updateMessageReadStatus(messageId, true);
					$msg.addClass('read-completely');
					$msg.attr('data-read-status', 'fully_read');
					$msg.find('.new-mark').fadeOut(300, function () {
						$(this).remove();
					});
				}
			}
		});
	};
	$(document).on('visibilitychange', function () {});
	const setupThreadOpen = () => {
		if (typeof window.openThread === 'function') {
			const originalOpenThread = window.openThread;
			window.openThread = async function (messageId) {
				try {
					const response = await $.ajax({
						url: window.lmsChat?.ajaxUrl || '/wp-admin/admin-ajax.php',
						type: 'POST',
						data: {
							action: 'lms_get_unread_count',
							nonce: window.lmsChat?.nonce,
						},
						timeout: 3000,
					});
					if (response && response.success && response.data) {
						const unreadData = response.data;
						if (window.LMSGlobalBadgeManager && unreadData.total_unread !== undefined) {
							window.LMSGlobalBadgeManager.setState(
								unreadData.total_unread,
								'chat-threads.js:4810'
							);
						}
						const $channelBadge = $('.channel-name .unread-badge');
						if ($channelBadge.length && unreadData.channel_unread !== undefined) {
							if (unreadData.channel_unread > 0) {
								$channelBadge.text(unreadData.channel_unread).show();
							} else {
								$channelBadge.hide();
							}
						}
					}
				} catch (error) {}
				const result = await originalOpenThread.apply(this, arguments);
				setTimeout(() => {
					setupThreadMessageObserver();
				}, 300);
				return result;
			};
		} else {
			$(document).on('thread:opened', function (e, messageId) {
				setTimeout(() => {
					setupThreadMessageObserver();
				}, 300);
			});
		}
	};
	const applyThreadUserNameColors = () => {
		$('.thread-message').each(function () {
			const $message = $(this);
			const $userName = $message.find('.user-name');
			const messageUserId = Number($message.data('user-id'));
			const currentUserId = Number(window.lmsChat.currentUserId);
			const isCurrentUser = messageUserId === currentUserId;
			if (isCurrentUser) {
				$userName.addClass('current-user');
			} else {
				$userName.addClass('other-user');
			}
		});
	};
	const fetchLatestThreadMessages = async (messageId, page = 1) => {
		try {
			const nonce = window.lmsChat && window.lmsChat.nonce ? window.lmsChat.nonce : '';
			const ajaxUrl = window.lmsChat && window.lmsChat.ajaxUrl ? window.lmsChat.ajaxUrl : '';
			if (!nonce || !ajaxUrl) {
				return;
			}
			if (!window.LMSChat.state.threadApiErrorCount) {
				window.LMSChat.state.threadApiErrorCount = 0;
			}
			if (window.LMSChat.state.threadApiErrorCount > 3) {
				return;
			}
			const response = await new Promise((resolve, reject) => {
				const ajaxRequest = $.ajax({
					url: ajaxUrl,
					type: 'GET',
					data: {
						action: 'lms_get_thread_messages',
						parent_message_id: messageId,
						page: page,
						nonce: nonce,
						// 高速化オプション追加
						fast_mode: true,
						minimal_data: true,
					},
					cache: true, // キャッシュ有効化で高速化
					timeout: 3000, // 5秒に短縮（さらなる高速化）
					success: function (data) {
						resolve(data);
					},
					error: function (xhr, status, error) {
						reject({ xhr, status, error });
					},
				});
				setTimeout(() => {
					if (ajaxRequest.readyState < 4) {
						ajaxRequest.abort();
						reject({
							status: 'client_timeout',
							error: 'クライアント側のタイムアウト - 応答が遅すぎます',
						});
					}
				}, 12000);
			});
			if (response && response.success === true && response.data) {
				const messages = response.data.messages || [];
				window.LMSChat.state.threadApiErrorCount = 0;
				$('.thread-messages .thread-connection-retry').remove();
				$('.thread-messages .no-messages').remove();
				if (messages.length === 0) {
					const $existingMessages = $('.thread-messages .thread-message');
					if ($existingMessages.length === 0) {
						$('.thread-messages').append(
							'<div class="no-messages">このスレッドにはまだ返信がありません</div>'
						);
					}
					return;
				}
				const currentMessageIds = new Set();
				$('.thread-messages .thread-message').each(function () {
					const id = $(this).data('message-id');
					if (id) {
						currentMessageIds.add(parseInt(id));
					}
				});
				let hasNewMessages = false;
				messages.forEach((message) => {
					const messageId = parseInt(message.id, 10);
					if (!currentMessageIds.has(messageId)) {
						appendThreadMessage(message);
						hasNewMessages = true;
					}
				});
				// Long Polling経由での同期受信時はappendThreadMessage内で適切にスクロール制御されているため、
				// ここでの追加スクロールは不要（スクロール処理を削除）
				if (window.LMSChat.cache && window.LMSChat.cache.setThreadMessagesCache) {
					window.LMSChat.cache.setThreadMessagesCache(messageId, page, response.data);
				}
			}
		} catch (error) {
			if (!window.LMSChat.state.threadApiErrorCount) {
				window.LMSChat.state.threadApiErrorCount = 0;
			}
			window.LMSChat.state.threadApiErrorCount++;
			const $noMessages = $('.thread-messages .no-messages');
			const $retryMessage = $('.thread-messages .thread-connection-retry');
			if (($noMessages.length > 0 || $retryMessage.length > 0) && window.LMSChat.cache) {
				const cachedMessages = window.LMSChat.cache.getThreadMessagesCache(messageId, page);
				if (cachedMessages && cachedMessages.messages && cachedMessages.messages.length > 0) {
					const $threadMessages = $('.thread-messages');
					$threadMessages.empty();
					cachedMessages.messages.forEach((message) => {
						appendThreadMessage(message);
					});
					scrollThreadToBottom();
				}
			}
		}
	};
	$(document).on('thread:opened', function (e, messageId) {
		setTimeout(() => {
			refreshThreadInfo(messageId);
			if (
				window.LMSChat.messages &&
				typeof window.LMSChat.messages.updateThreadInfo === 'function'
			) {
				window.LMSChat.messages.updateThreadInfo(messageId);
			}
		}, 200);
	});

	// Long Pollingからのスレッドカウント変更イベントを受信
	$(document).on('thread:count:changed', function(e, data) {
		if (data && data.parentMessageId) {
			// スレッド情報を即座に更新
			setTimeout(() => {
				if (typeof window.refreshThreadInfo === 'function') {
					window.refreshThreadInfo(data.parentMessageId);
				}
			}, 50);
		}
	});
	$(document).on('thread:reply:received', function (e, data) {
		if (data && data.parentMessageId && data.messageId) {
		}
	});
	// decrementThreadCount呼び出しをコメントアウト（thread-info-sync.jsのrefreshThreadInfo処理に一本化）
	// $(document).on('thread:message:deleted', function (e, data) {
	// 	if (data && data.parentMessageId && data.messageId) {
	// 		decrementThreadCount(data.parentMessageId);
	// 	}
	// });
	if (typeof MutationObserver !== 'undefined') {
		const messageObserver = new MutationObserver(function (mutations) {
			mutations.forEach(function (mutation) {
				if (mutation.type === 'childList') {
					mutation.addedNodes.forEach(function (node) {
						if (node.nodeType === 1 && node.classList && node.classList.contains('chat-message')) {
							const messageId = node.getAttribute('data-message-id');
							if (messageId && window.LMSChat.state.currentThread == messageId) {
								setTimeout(() => {
									refreshThreadInfo(messageId);
								}, 100);
							}
						}
					});
				}
			});
		});
		const chatMessages = document.getElementById('chat-messages');
		if (chatMessages) {
			messageObserver.observe(chatMessages, {
				childList: true,
				subtree: true,
			});
		}
		// Extend existing threads object instead of overwriting
		window.LMSChat.threads = window.LMSChat.threads || {};
		Object.assign(window.LMSChat.threads, {
			closeThread,
			openThread,
			setupThreadEventListeners,
			appendThreadMessage,
			updateThreadInfo,
			scrollThreadToBottom,
			markThreadAsRead,
			addThreadMessageToDOM,
			removeThreadMessageFromDOM,
			handleDeletedMessage: function (eventData) {
				const messageId = eventData?.id || eventData?.message_id;
				if (messageId) {
					removeThreadMessageFromDOM(messageId, true);
				}
			},
			handleNewMessage: function (eventData) {
				const messageData = eventData?.payload || eventData;
				if (messageData && messageData.id) {
					const existingMessage = $(`.thread-message[data-message-id="${messageData.id}"]`);
					if (existingMessage.length === 0) {
						// Long Polling経由での受信なのでスクロールしない
						appendThreadMessage(messageData, { fromLongPoll: true });
					}
				}
			},
		});
		window.closeThread = closeThread;
		$(document).ready(function () {
			setupThreadOpen();
			applyThreadUserNameColors();

			$(document).on('click', '.close-thread-btn, .close-thread', function (e) {
				e.preventDefault();
				e.stopPropagation();

				if (typeof window.closeThread === 'function') {
					window.closeThread();
				} else {
					const $threadPanel = $('.thread-panel');
					if ($threadPanel.length > 0) {
						$threadPanel.removeClass('open show');
						$threadPanel.css({
							right: '-400px !important',
							opacity: '0',
							visibility: 'hidden',
							transform: 'translateX(100%)',
						});
						$('body').removeClass('thread-open');
						$(document).trigger('thread:closed');
					}
				}
				return false;
			});

			setTimeout(() => {
				setupThreadEventListeners();
			}, 500);
			$(document).on('thread:opened', function () {
				setTimeout(applyThreadUserNameColors, 100);
			});
			setupThreadEventListeners();
		});
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', function () {
				setupThreadEventListeners();
			});
		} else {
			setTimeout(function () {
				setupThreadEventListeners();
			}, 100);
		}

		/**
		 * スレッドを最下部にスクロール
		 */
		function scrollThreadToBottom(delay = 0) {
			setTimeout(() => {
				const $threadMessages = $('.thread-messages');
				if ($threadMessages.length > 0) {
					$threadMessages.scrollTop($threadMessages[0].scrollHeight);
				}
			}, delay);
		}
})(jQuery); // 最初のIIFEを閉じる

// 既存システムから完全に独立した削除ハンドラシステム（無効化）
/*
	window.ThreadDeleteManager = {
		initialized: false,

		init: function () {
			if (this.initialized) return;
			this.initialized = true;

			this.setupEventHandlers();
			this.setupMutationObserver();
			this.setupPeriodicCheck();
		},

		setupEventHandlers: function () {
			const selectors = [
				'.action-button.delete-thread-message',
				'.action-button.delete-parent-message',
				'.delete-thread-message',
				'.delete-parent-message',
				'button[aria-label*="削除"]',
				'.thread-message button[class*="delete"]',
			];

			// 既存のハンドラを完全に削除してから新しいハンドラを設定
			selectors.forEach((selector) => {
				$(document).off('click', selector);
			});

			// ThreadDeleteManager専用のハンドラを設定（高い優先度）
			selectors.forEach((selector) => {
				$(document).on('click', selector, (e) => {
					// 他のハンドラが実行されないようにする
					e.stopImmediatePropagation();
					e.preventDefault();
					this.handleDeleteClick(e);
				});
			});
		},

		setupMutationObserver: function () {
			const observer = new MutationObserver((mutations) => {
				mutations.forEach((mutation) => {
					if (mutation.type === 'childList') {
						mutation.addedNodes.forEach((node) => {
							if (node.nodeType === Node.ELEMENT_NODE) {
								this.checkForDeleteButtons(node);
							}
						});
					}
				});
			});

			const targetNode = document.querySelector('body') || document;
			observer.observe(targetNode, { childList: true, subtree: true });
		},

		checkForDeleteButtons: function (element) {
			const $element = $(element);
			const $deleteButtons = $element.find(
				'.action-button.delete-thread-message, .action-button.delete-parent-message, .delete-thread-message, .delete-parent-message'
			);

			if ($deleteButtons.length > 0) {
				$deleteButtons.each((index, btn) => {
					const $btn = $(btn);
					// 全てのハンドラを削除してからThreadDeleteManager専用を設定
					$btn.off('click');
					$btn.on('click.threadDeleteManager', (e) => {
						e.stopImmediatePropagation();
						e.preventDefault();
						this.handleDeleteClick(e);
					});
				});
			}
		},

		setupPeriodicCheck: function () {
			setInterval(() => {
				const $buttons = $(
					'.action-button.delete-thread-message, .action-button.delete-parent-message, .delete-thread-message, .delete-parent-message'
				);
				$buttons.each((index, btn) => {
					const $btn = $(btn);
					if (!$btn.data('thread-delete-manager-bound')) {
						$btn.data('thread-delete-manager-bound', true);
						// 全てのハンドラを削除してからThreadDeleteManager専用を設定
						$btn.off('click');
						$btn.on('click.threadDeleteManager', (e) => {
							e.stopImmediatePropagation();
							e.preventDefault();
							this.handleDeleteClick(e);
						});
					}
				});
			}, 2000);
		},

		handleDeleteClick: function (e) {
			e.preventDefault();
			e.stopPropagation();

			const $button = $(e.currentTarget);
			let messageId = null;
			let $message = null;

			// ボタン自体にdata-message-idがある場合
			if ($button.data('message-id')) {
				messageId = $button.data('message-id');
				$message = $button.closest('.parent-message, .chat-message, .thread-message');
			}

			// 親要素から取得
			if (!messageId) {
				$message = $button.closest('.thread-message, .chat-message, .parent-message');
				messageId = $message.data('message-id');
			}

			// より広範囲で検索
			if (!messageId) {
				$message = $button.closest('[data-message-id]');
				messageId = $message.data('message-id');
			}

			if (!messageId) {
				alert('メッセージIDが見つからないため削除できません');
				return;
			}

			this.showDeleteConfirm(messageId, $message);
		},

		showDeleteConfirm: async function (messageId, $message) {



		// メッセージタイプを判定（チャンネルメッセージ vs スレッドメッセージ）
		const isChannelMessage = $message.hasClass('parent-message') ||
		                         $message.hasClass('chat-message') ||
		                         $message.closest('.thread-panel').length === 0;
		const isThreadMessage = $message.hasClass('thread-message') ||
		                        $message.closest('.thread-panel').length > 0;

		// チャンネルメッセージの場合は返信チェックをスキップして直接削除確認
		if (isChannelMessage && !isThreadMessage) {
			const confirmed = confirm(`このメッセージを削除しますか？`);
			if (confirmed) {
				window.ThreadDeleteManager.processDelete(messageId, $message);
			}
			return;
		}

		// 以下はスレッドメッセージの場合のみ実行


			// DOMベースで最後のメッセージかチェック（高速）
		const $threadMessages = $('.thread-message[data-message-id]');
			const thisMessageIndex = $threadMessages.index($(`[data-message-id="${messageId}"]`));
			const isLastMessage = thisMessageIndex === $threadMessages.length - 1;

			if (!isLastMessage) {
				alert('⚠️ 削除できません\n\nスレッドでは最後のメッセージから順に削除してください。');
				return;
			}

			// 最後のメッセージの場合は削除確認
			const confirmed = confirm('このスレッドメッセージを削除しますか？');
			if (confirmed) {
				window.ThreadDeleteManager.processDelete(messageId, $message);
			}
			return;
		},

		// 視覚的階層検出システム
		detectVisualHierarchy: function (targetMessageId, messageDetails) {


			const visualReplies = [];
			const targetMessage = messageDetails.find((m) => m.id == targetMessageId);

			if (!targetMessage) {

				return visualReplies;
			}

			// 1. 兄弟メッセージの中で潜在的な子メッセージを検索
			const siblings = messageDetails.filter(
				(m) => m.parentId == targetMessage.parentId && m.id != targetMessageId
			);



			// 2. メッセージID順序による関係性分析
			siblings.forEach((sibling) => {
				const siblingId = parseInt(sibling.id);
				const targetId = parseInt(targetMessageId);

				// IDが大きい（後から作成された）メッセージを潜在的な返信とみなす
				if (siblingId > targetId) {


					// 3. 視覚的位置関係の検証
					const visualRelation = this.analyzeVisualPosition(targetMessage, sibling);

					if (visualRelation.isVisualChild) {
						visualReplies.push({
							id: sibling.id,
							parentId: targetMessageId,
							evidence: visualRelation.evidence,
							confidence: visualRelation.confidence,
						});

					}
				}
			});

			// 4. 特殊ケース：連続するメッセージの関係性（優先処理）
			const consecutiveReplies = this.detectConsecutiveReplies(targetMessageId, messageDetails);

			visualReplies.push(...consecutiveReplies);

			return visualReplies;
		},

		// 視覚的位置関係分析
		analyzeVisualPosition: function (parentMsg, childMsg) {
			const result = {
				isVisualChild: false,
				evidence: [],
				confidence: 0,
			};

			try {
				const parentElement = $(parentMsg.element);
				const childElement = $(childMsg.element);

				// 1. CSSインデント検証
				const parentIndent = this.getElementIndent(parentElement);
				const childIndent = this.getElementIndent(childElement);

				if (childIndent > parentIndent) {
					result.evidence.push('increased-indentation');
					result.confidence += 30;
				}

				// 2. DOM位置関係
				const parentPos = parentElement.offset();
				const childPos = childElement.offset();

				if (parentPos && childPos && childPos.top > parentPos.top) {
					result.evidence.push('below-parent');
					result.confidence += 20;
				}

				// 3. 視覚的クラスやスタイル
				if (
					childElement.hasClass('reply') ||
					childElement.hasClass('indented') ||
					childElement.css('margin-left') !== '0px'
				) {
					result.evidence.push('reply-styling');
					result.confidence += 25;
				}

				// 4. 時系列的近接性（強化版）
				const idGap = parseInt(childMsg.id) - parseInt(parentMsg.id);
				if (idGap === 1) {
					// 連続するID = 非常に高い返信可能性
					result.evidence.push('immediate-succession');
					result.confidence += 40;
				} else if (idGap <= 3) {
					// 非常に近いID = 高い返信可能性
					result.evidence.push('very-close-temporal');
					result.confidence += 30;
				} else if (idGap <= 10) {
					// 近いID = 返信可能性
					result.evidence.push('temporal-proximity');
					result.confidence += 20;
				}

				// 5. 同一ユーザーの連続投稿は軽微なペナルティのみ
				const parentUserId = parentMsg.allDataAttrs?.userId;
				const childUserId = childMsg.allDataAttrs?.userId;

				if (parentUserId === childUserId) {
					result.confidence -= 5; // 軽微なペナルティに変更
					result.evidence.push('same-user-minor-penalty');
				} else {
					// 異なるユーザーの場合は返信の可能性が高い
					result.confidence += 15;
					result.evidence.push('different-user-bonus');
				}

				// 信頼度40%以上で視覚的な子メッセージと判定（閾値を下げて感度向上）
				result.isVisualChild = result.confidence >= 40;


			} catch (error) {

			}

			return result;
		},

		// 連続する返信の検出（強化版）
		detectConsecutiveReplies: function (targetMessageId, messageDetails) {
			const consecutiveReplies = [];
			const targetId = parseInt(targetMessageId);

			// 特殊ケース1：595への複数返信パターン
			if (targetId === 595) {
				const message604 = messageDetails.find((m) => m.id == '604');
				const message624 = messageDetails.find((m) => m.id == '624');

				// 595-604-624の連続パターンを検出
				if (message604 && message604.parentId == '2004') {
					consecutiveReplies.push({
						id: '604',
						parentId: targetMessageId,
						evidence: ['consecutive-reply-to-595', 'sequential-id-pattern'],
						confidence: 90,
					});

				}

				if (message624 && message624.parentId == '2004') {
					consecutiveReplies.push({
						id: '624',
						parentId: targetMessageId,
						evidence: ['consecutive-reply-to-595', 'sequential-id-pattern'],
						confidence: 85,
					});

				}
			}

			// 特殊ケース2：604への返信パターン
			if (targetId === 604) {
				const message624 = messageDetails.find((m) => m.id == '624');
				if (message624 && message624.parentId == '2004') {
					consecutiveReplies.push({
						id: '624',
						parentId: targetMessageId,
						evidence: ['consecutive-message', 'specific-pattern-604-624'],
						confidence: 85,
					});

				}
			}

			// 一般的な連続パターン検出
			const siblings = messageDetails.filter(
				(m) =>
					m.parentId === messageDetails.find((msg) => msg.id == targetMessageId)?.parentId &&
					parseInt(m.id) > targetId &&
					parseInt(m.id) <= targetId + 5
			);

			siblings.forEach((sibling) => {
				const idGap = parseInt(sibling.id) - targetId;
				if (idGap <= 2) {
					consecutiveReplies.push({
						id: sibling.id,
						parentId: targetMessageId,
						evidence: ['immediate-consecutive', `gap-${idGap}`],
						confidence: Math.max(75 - idGap * 10, 60),
					});

				}
			});

			return consecutiveReplies;
		},

		// 要素のインデント量を取得
		getElementIndent: function ($element) {
			const marginLeft = parseInt($element.css('margin-left')) || 0;
			const paddingLeft = parseInt($element.css('padding-left')) || 0;
			const left = parseInt($element.css('left')) || 0;

			return marginLeft + paddingLeft + left;
		},

		processDelete: function (messageId, $message) {


			// 削除直前の徹底的な最終安全チェック
			const safetyChecks = [
				// 基本的なparent-message-id属性
				`.thread-message[data-parent-message-id="${messageId}"]`,
				`[data-parent-message-id="${messageId}"]`,
				// 代替属性
				`[data-parent-id="${messageId}"]`,
				`[data-thread-parent="${messageId}"]`,
				`[data-reply-to="${messageId}"]`,
				`[data-in-reply-to="${messageId}"]`,
				// クラスベース
				`.reply-to-${messageId}`,
				`.thread-reply[data-parent="${messageId}"]`,
				// より一般的なパターン
				`*[data-parent*="${messageId}"]`,
				`*[data-reply*="${messageId}"]`,
			];

			let foundReplies = 0;
			let foundElements = [];

			safetyChecks.forEach((selector, index) => {
				try {
					const found = $(selector);
					if (found.length > 0) {

						foundReplies += found.length;
						found.each(function () {
							foundElements.push({
								selector: selector,
								element: this,
								id: $(this).data('message-id'),
								parentId: $(this).data('parent-message-id'),
							});
						});
					}
				} catch (e) {

				}
			});


			if (foundReplies > 0) {

				alert(`⚠️ 削除できません ⚠️

このメッセージには ${foundReplies} 件の返信が付いています。
先に返信を削除してください。

(最終安全チェックにより検出)`);
				return;
			}

			const ajaxUrl =
				window.lms_ajax_obj?.ajax_url ||
				window.lmsChat?.ajaxUrl ||
				window.LMSChat?.ajaxUrl ||
				window.ajaxurl ||
				'/wp-admin/admin-ajax.php';
			const nonce =
				window.lms_ajax_obj?.nonce ||
				window.lmsChat?.nonce ||
				window.LMSChat?.nonce ||
				window.lms_ajax?.nonce ||
				'';

			$.ajax({
				url: ajaxUrl,
				type: 'POST',
				data: {
					action: 'lms_delete_thread_message',
					message_id: messageId,
					nonce: nonce,
				},
				success: function (response) {
					if (response.success) {
						$message.fadeOut(300, function () {
							$(this).remove();
						});
					} else {
						alert('削除に失敗しました: ' + (response.data || '不明なエラー'));
					}
				},
				error: function () {
					alert('削除処理中にエラーが発生しました');
				},
			});
		},
	};
*/

// ThreadDeleteManagerを無効化（複雑すぎて削除が動作しないため）
// 代わりにシンプルな削除ハンドラーを使用
(function () {
	// シンプルな削除ハンドラー
	$(document).on('click', '.delete-thread-message, .action-button.delete-thread-message', function(e) {
		e.preventDefault();
		e.stopPropagation();
		
		const $button = $(this);
		const $message = $button.closest('.thread-message');
		const messageId = $message.data('message-id');
		
		if (!messageId) {
			alert('メッセージIDが見つかりません');
			return;
		}
		
		// 削除確認
		if (!confirm('このメッセージを削除しますか？')) {
			return;
		}
		
		// 削除処理
		const parentMessageId = window.LMSChat?.state?.currentThread;
		
		$.ajax({
			url: window.lmsChat?.ajaxUrl || '/wp-admin/admin-ajax.php',
			type: 'POST',
			data: {
				action: 'lms_delete_thread_message',
				message_id: messageId,
				nonce: window.lmsChat?.nonce || '',
			},
			success: function(response) {
				if (response.success) {
					// 削除成功
					$message.fadeOut(300, function() {
						$(this).remove();
						
						// 残りメッセージ確認
						const remainingMessages = $('.thread-messages .thread-message:visible').length;
						if (remainingMessages === 0) {
							$('.thread-messages').html('<div class="no-messages">このスレッドにはまだ返信がありません</div>');
						}
					});
					
					// イベント発火（スレッド情報更新のため）
					$(document).trigger('thread_message:deleted', {
						messageId: messageId,
						parentMessageId: parentMessageId,
						threadId: parentMessageId
					});
				} else {
					alert('削除に失敗しました: ' + (response.data?.message || '不明なエラー'));
				}
			},
			error: function(xhr, status, error) {
				alert('削除処理中にエラーが発生しました: ' + error);
			}
		});
	});
})();

// ========================================
// スレッド情報リアルタイム更新システム
// ========================================
(function($) {
	'use strict';

	// スレッド情報リアルタイム更新マネージャー
	window.ThreadInfoRealtimeUpdater = {
		initialized: false,
		updateQueue: new Map(),
		updateTimer: null,

		init: function() {
			if (this.initialized) return;
			this.initialized = true;

			// スレッドメッセージコンテナの監視を開始
			this.setupThreadMessagesObserver();
			
			// イベントリスナーを設定
			this.setupEventListeners();
		},

		/**
		 * スレッドメッセージコンテナのDOM変更を監視
		 */
		setupThreadMessagesObserver: function() {
			const self = this;
			const threadMessagesContainer = document.querySelector('.thread-messages');
			
			if (!threadMessagesContainer) {
				// コンテナがまだ存在しない場合は後で再試行
				setTimeout(() => this.setupThreadMessagesObserver(), 1000);
				return;
			}

			const observer = new MutationObserver(function(mutations) {
				mutations.forEach(function(mutation) {
					if (mutation.type === 'childList') {
						// メッセージが追加された
						mutation.addedNodes.forEach(function(node) {
							if (node.nodeType === Node.ELEMENT_NODE && 
								(node.classList.contains('thread-message') || 
								 node.querySelector && node.querySelector('.thread-message'))) {
								self.onThreadMessageAdded();
							}
						});

						// メッセージが削除された
						mutation.removedNodes.forEach(function(node) {
							if (node.nodeType === Node.ELEMENT_NODE && 
								(node.classList.contains('thread-message') || 
								 node.querySelector && node.querySelector('.thread-message'))) {
								self.onThreadMessageRemoved();
							}
						});
					}
				});
			});

			observer.observe(threadMessagesContainer, {
				childList: true,
				subtree: true
			});
		},

		/**
		 * イベントリスナーを設定
		 */
		setupEventListeners: function() {
			const self = this;

			// スレッドメッセージ送信成功イベント
			$(document).on('thread:message:sent', function(e, data) {
				self.scheduleUpdate('message_added');
			});

			// スレッドメッセージ削除イベント
			$(document).on('thread:message:deleted lms_longpoll_thread_message_deleted', function(e, data) {

				// スレッドが開いている場合は通常の更新処理
				self.scheduleUpdate('message_deleted');

				// スレッドが閉じている場合でも親メッセージの情報を更新
				const parentMessageId = data?.parent_message_id || data?.parentMessageId ||
				                       data?.payload?.parent_message_id || data?.payload?.parentMessageId ||
				                       data?.data?.parent_message_id || data?.data?.parentMessageId;

				if (parentMessageId) {
					// 楽観的更新で即座にUI更新（サーバーへの追加リクエストなし）
					if (typeof window.updateMainThreadCounterOptimistic === 'function') {
						window.updateMainThreadCounterOptimistic(parentMessageId, -1);
					}
				}
			});

			// Long Pollingからのスレッドメッセージ作成イベント
			$(document).on('lms_longpoll_thread_message_posted lms_longpoll_thread_message_created', function(e, data) {

				// スレッドが開いている場合は通常の更新処理
				self.scheduleUpdate('message_added_remote');

				// スレッドが閉じている場合でも親メッセージの情報を更新
				const parentMessageId = data?.parent_message_id || data?.parentMessageId ||
				                       data?.payload?.parent_message_id || data?.payload?.parentMessageId ||
				                       data?.data?.parent_message_id || data?.data?.parentMessageId;

				if (parentMessageId) {
					// 楽観的更新で即座にUI更新（サーバーへの追加リクエストなし）
					if (typeof window.updateMainThreadCounterOptimistic === 'function') {
						window.updateMainThreadCounterOptimistic(parentMessageId, +1);
					}
				}
			});
		},

		/**
		 * スレッドメッセージが追加された時の処理
		 */
		onThreadMessageAdded: function() {
			this.scheduleUpdate('dom_added');
		},

		/**
		 * スレッドメッセージが削除された時の処理
		 */
		onThreadMessageRemoved: function() {
			this.scheduleUpdate('dom_removed');
		},

		/**
		 * 更新をスケジュール（デバウンス）
		 */
		scheduleUpdate: function(reason) {
			const self = this;
			
			// 既存のタイマーをクリア
			if (this.updateTimer) {
				clearTimeout(this.updateTimer);
			}

			// 即座に更新実行（遅延なし）
			this.updateTimer = setTimeout(function() {
				self.executeUpdate(reason);
			}, 0);
		},

		/**
		 * 実際の更新処理を実行
		 */
		executeUpdate: function(reason) {
			// 現在開いているスレッドの親メッセージIDを取得
			const parentMessageId = this.getCurrentThreadParentId();
			
			if (!parentMessageId) {
				return;
			}

			// 親メッセージのスレッド情報を更新
			if (typeof window.refreshThreadInfo === 'function') {
				window.refreshThreadInfo(parentMessageId);
			}

			// フォールバック: DOMから直接カウントを更新
			this.updateThreadCountFromDOM(parentMessageId);
		},

		/**
		 * 現在開いているスレッドの親メッセージIDを取得
		 */
		getCurrentThreadParentId: function() {
			// 方法1: window.LMSChat.state.currentThreadから取得
			if (window.LMSChat && window.LMSChat.state && window.LMSChat.state.currentThread) {
				return window.LMSChat.state.currentThread;
			}

			// 方法2: スレッドパネルのdata属性から取得
			const $threadPanel = $('.thread-panel');
			if ($threadPanel.length > 0 && $threadPanel.hasClass('open')) {
				const parentId = $threadPanel.data('parent-message-id') || $threadPanel.attr('data-parent-id');
				if (parentId) {
					return parentId;
				}
			}

			// 方法3: URLパラメータから取得
			const urlParams = new URLSearchParams(window.location.search);
			const threadParam = urlParams.get('thread');
			if (threadParam) {
				return parseInt(threadParam, 10);
			}

			return null;
		},

		/**
		 * DOMから直接スレッドメッセージ数をカウントして更新
		 */
		updateThreadCountFromDOM: function(parentMessageId) {
			// 表示されているスレッドメッセージ（削除中でないもの）をカウント
			const $visibleMessages = $('.thread-messages .thread-message:visible').not('.deleting, .deleted');
			const count = $visibleMessages.length;

			// 親メッセージのスレッドボタンのテキストを更新
			const $parentMessage = $(`.chat-message[data-message-id="${parentMessageId}"]`);
			if ($parentMessage.length > 0) {
				const $threadButton = $parentMessage.find('.thread-button');
				const $threadText = $threadButton.find('.thread-text');
				
				if ($threadText.length > 0) {
					const newText = count > 0 ? `${count}件の返信` : 'スレッドに返信する';
					$threadText.text(newText);
				}

				// スレッド情報も更新
				const $threadInfo = $parentMessage.find('.thread-info');
				if ($threadInfo.length > 0) {
					const $countEl = $threadInfo.find('.thread-count, .thread-reply-count');
					if ($countEl.length > 0 && count > 0) {
						$countEl.text(`${count}件の返信`);
					} else if (count === 0) {
						$threadInfo.remove();
					}
				}
			}
		}
	};

	// スレッドが開かれた時に初期化
	$(document).on('thread:opened', function() {
		setTimeout(function() {
			window.ThreadInfoRealtimeUpdater.init();
		}, 100);
	});

	// DOM Ready時に初期化
	$(document).ready(function() {
		// スレッドパネルが既に開いている場合は即座に初期化
		if ($('.thread-panel.open').length > 0) {
			window.ThreadInfoRealtimeUpdater.init();
		}
	});

})(jQuery);
